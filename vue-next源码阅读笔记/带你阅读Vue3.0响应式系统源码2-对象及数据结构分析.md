# 带你阅读Vue3.0响应式系统源码2-对象及数据结构分析

## 主题：对象及数据结构分析

### 1.全局实例对象

#### 1）存放所有对象依赖筐的实例对象（在effect.ts文件顶部）

​	存放所有对象依赖筐的实例对象只有一个，叫做**targetMap**，它是分成三层的树状数据结构，第一二层是**Map**数据类型，第三层是**Set**数据类型。它大体上是按照如下的结构进行组织的：

![](images/Untitled Diagram (13)-1580392142293.png)

在讲解上面数据结构之前，先说明清楚两点：

- 在**Vue**的**数据响应系统中，数据对象变成响应型数据和被观察的数是两码事**。并且，**响应性数据不一定是被观察的数据，被观察的数据一定是响应型数据**。
- 数据变成响应型数据仅仅是加一层代理而已，并**不会对原本数据进行任何处理**

接下来逐一对上面的**Map**和**Set**进行解释

1. **targetMap**作为本数据结构的根目录结构：
   - 它的键存放着**未代理的被观察的对象**，一旦有数据被观察了，它就会被放到这个**targetMap**，所以**targetMap**的话最后存储所有被观察的对象（包括对象中的子对象），这里的对象包括对象、数组、容器。
   - 它的值是一个**Map**实例，存放着**被观察对象的所有被观察的属性**
2. **KeyToDepMap**存放着某个被观察的对象中被观察的属性所对应依赖筐**Dep**。
   - 在**Vue2.0**中，每个数据要变成一个响应型数据都要有一个**Dep筐（那时候叫做依赖筐）**，这个对象每次被**Watcher**引用的时候，就会在这个**Dep**筐添加**Watcher**实例，所以它应该是一个容器类型。
   - 在**Vue3.0**的时候，**Dep**筐基本上和**Vue2.0**一样也是一个容器类型，存放着所有引用这个数据的**Effect**对象。
   - ps：如果你还没有理清**Dep和Watcher之间的关系**：[带你理清Vue2.0中的Dep和Watcher的关系](<https://juejin.im/post/5e23fcb1f265da3e2650e17e>)
3. **Dep**是一个存放着**ReactiveEffect**数据类型的一个集合（**Set**），这种数据类型的我们在下面成为**Effect**对象，使用**Set**而不使用**Array**的意图很简单，就是为了去重。

#### 2）存放原生对象和代理对象关系的Map

​	我们知道，使用**Proxy**和**Reflect**进行实现数据响应系统的话，原生数据变成响应型数据的话，仅仅是加一层代理。使用两种对象进行互转的原因有两个：

- 进行代理后，面向用户（即程序员的只是一个代理对象），而原本的原生数据如果不进行处理的话，可能会丢失引用（但不会被GC）。
- 内部有时候使用的是原生对象，有时候使用的是代理对象，如此复杂的情况下，需要有一种互转的机制。

```typescript
// 使用WeakMap的原因可以去查一下GC对于弱引用的处理方式
const rawToReactive = new WeakMap<any, any>()
const reactiveToRaw = new WeakMap<any, any>()
```

#### 3）依赖添加所需要的全局对象

​	在前面说过，**Effect**对象相当于2.0中的**Watcher**对象，那么在进行依赖的绑定的时候，也就是执行第一次执行**Effect**方法的时候，会进行依赖的绑定。这跟2.0一样，需要两个全局变量：

- **activeEffect**：当前活跃的**Effect**实例，在初始化**Effect**实例的时候，进行添加依赖的时候方便响应型数据进行获取**effect**对象从而实现依赖的绑定。
- **effectStack**：存放**Effect**的数组，充当一个栈使用。

这两个全局变量跟2.0的两个全局变量的作用是一样的：

```javascript
Dep.target = null
const targetStack = []
```

整个依赖的绑定流程如下：

不过首先要说明一下里面变量的情况：

- **activeEffect**：当前正在执行的**Effect**实例。
- **Dep**通过**targetMap**进行查找得到访问的数据的**Dep筐**，执行一个次**activeEffect**函数，可能有多个依赖绑定，也可能没有，完全取决于函数中对响应型数据的访问情况。

![Untitled Diagram (images/Untitled Diagram (15).png)](../../../../Downloads/Untitled Diagram (15).png)

### 2.普通对象类型

#### ​1）Effect类型对象	

​	上面多次提到了**Effect**，那么**Effect**是什么东西呢？笔者第一眼看到它，就觉得跟2.0的**Watcher**很像，以为它就是**Watcher**改个名字而已，但是当我看到整个**packages/reactivity**目录的代码后，去寻找创建观察者的三种方式（在[带你理清Vue2.0中的Dep和Watcher的关系](<https://juejin.im/post/5e23fcb1f265da3e2650e17e>) 这篇文章中，我根据自己的想法将**Watcher**分成三类，它们分别是）**WatchAPI、render、computed**。粗略看了三者的代码，发现**Effect**其实只是**Watcher**的一部分。它有以下的特点：

- 它是一个带有属性的**Function**实例，**Function**就相当于**Watcher**的回调方法，每次修改被观察的数据后，就是执行这个回调函数。
- **deps**存放回调函数引用的数据的**dep筐**，这跟2.0的**Watcher和Dep**关系一致
- 前面两个属性是一定会有的，但是接下来这个属性很重要，但是**Effect**本身不提供，它就是**scheduler**方法，它决定了数据触发后，怎么进行执行数据回调，可以是懒求值、可以是微观队列执行等等，它本身不会提供的。而是由创建它的人进行提供。

与**Watcher**比较：

- **Watcher**就相当于一个大熔炉，它从观察者的诞生、依赖的添加、依赖的执行都有规定的方法，在实例化这个对象的时候只需要用一个标志位标志是哪种类型的观察者（代码中没有明确哪个标志位说明观察者的类型，但是可以有**lazy**、是否是渲染函数观察者这两个参数间接说明了它是有类型的）。
- **Effect**：相当于一个插槽，调用者进行调用的时候，说明类型后还得自带执行方法才能进行。所以**Effect**更加轻便灵活，更加抽象。**Vue3.0**已经很明确将三种观察者对象进行分离了，所以**Effect**的存在自有它的道理。

#### 2）Dep筐

​	在**Vue2.0**中，**Dep**还是一个类呢，为什么到**Vue3.0**却只是一个**Set**呢？其实可以去观察一下**Dep**这个类，看看它是不是跟**Set**长得差不多，并且**Dep**的作用就是存放某个数据所有绑定的**Watcher**，它的底层还是用**Array**实现的，那为什么不用**Set**来代替（况且**Set**还能去重）呢？