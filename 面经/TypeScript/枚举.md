# TypeScript的枚举

### 数字型枚举

typescript在定义枚举型数据的时候，如果对枚举的值不进行确定的话，那么会默认为数字型枚举，比如：

```typescript
enum MyEnum {
  one,			// 0
  two,      // 1
  three			// 2
}
```

处理的结果如上图，会从0开始对内容进行排序。如果我们想要不这么排也行，我们可以对数字型枚举进行设定值，如下：

```
enum MyEnum {
  one = 1,			// 1
  two,     			// 2
  three = 4			// 4
  four					// 5
}
```

可以看到，如果对枚举变量进行设置值的话，在这个值的之后会进行加1操作，也就是相当于一个台阶的作用。

如果是以下的形式的话，则会产生两个相同的枚举内容

```typescript
enum MyEnum {
  one = 1,			// 1
  two,     			// 2
  three = 2			// 2
}
```

这样会产生不少错误，所以不建议这么使用。

特别地，在数字型枚举对象中，最终会通过一个函数生成一个反向映射表放在该对象中。如下例子：

```typescript
enum NumEnum { one, two }
NumEnum.one => 0
NumEnum[1] => 'two'
// 其实这个不难理解，编译的过程就像官网举的栗子：
var NumEnum;
(function (NumEnum) {
    NumEnum[NumEnum["one"] = 0] = "one";
    NumEnum[NumEnum["two"] = 1] = "two";
})(NumEnum || (NumEnum = {}));
// 对象支持以 number 类型的数据作为键
```

这样的话，最后枚举就是一个对象，当枚举内容为数字的时候，就会产生一个反向映射表。

**如果没枚举量相同的话，反向映射内容就会缺少项，所以不建议这么使用**。

数字型枚举量可以通过函数生成、位移运算符生成等等。

### 字符串型枚举

```typescript
// 全部使用字符串字面量来初始化
enum StrEnum1 {
  one = 'one',
  two = 'two'
}

// 全部使用其他枚举成员的字面量初始化，
// 当然不仅限于 StrEnum1 枚举，也可以是其他字符串枚举
enum StrEnum2 {
  one = StrEnum.one,
  two = StrEnum.two
}

// 但是不可将这两种方式初始化方式混写
enum StrEnum3 {
  // 编辑器会报错
  one = 'first',
  // 采用计算属性的枚举表达式，ts 会认为你在初始化一个数字枚举，
  // 但是如果当前枚举含有字符串枚举成员，这回形成矛盾，所以会报错；
  two = StrEnum.two
  // 当然你可以手动指定常数枚举成员，从而避开这种校验；
  // ok
  three = 3
}
// 你可能会对上述第二种初始化枚举有疑问，为什么均使用其他枚举引用不会有问题
// 这是因为 ts 不会校验引用枚举成员
// 如果都为常数，那么就是数字枚举，如果都为字符串，就是字符串枚举，否则就是异构枚举。
```

字符串枚举是不会产生**反向映射**的。

字符串枚举的话，要么一切是通过其他枚举变量来进行赋值的，要么就是自己手动定义，不能存在两种方式。

### const定义的枚举

const枚举的话，最终不会生成一个对象来进行存储映射关系，而是将引用到的枚举变量直接赋给代码中使用到的时候的变量。

### declare定义的枚举

只进行声明，而不会产生，因为declare只是进行声明，在代码编写中会比较容易上手。