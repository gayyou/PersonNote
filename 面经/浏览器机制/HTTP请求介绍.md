[TOC]

### HTTP

##### 概念

- http是无状态、无连接的、基于TCP的应用层超文本报文协议，

##### 请求过程

- 首先确定请求的url是不是一个域名，如果是一个域名，会去DNS系统查询对应的ip地址
- TCP通过拿到的url进行三次握手连接
- 连接完毕后http将url、请求版本等信息请求封装头部和将数据封装成报文体，将其转为字节流让tcp进行封装。
- 服务端拿到所有数据后，转为http协议。运行对应的服务，返回数据
- 客户端拿到数据后，拿到http头部，查看connection字段，如果是close 的话，关闭tcp请求，如果connection是keep-alive的话，则会保留一段时间。

### HTTP请求的Keep-Alive

1.HTTP Keep-Alive

##### 1）简介

 	在`HTTP1.0`之前，浏览器的每个`http`请求都需要创建一个`TCP`连接，然后请求完毕后会将`TCP`连接进行释放。但是在`HTTP1.0`和`HTTP1.1`之后，请求头有了`Keep-Alive`字段，表示将存活，也就是请求完毕后不要去关闭`TCP`连接，然后允许被下一次请求使用`TCP`连接。在`Keep-Alive`字段的值中，存在有`timeout=5, max=100`字段，前者表示过期时间，后者表示最大连接次数。

​	在`Keep-Alive`中实现了`TCP`的串行复用，可能如果前面的请求一直得不到结果，那么会进行阻塞作用。

​	如果鉴别不同的请求呢？响应头会有两个字段，`Content-Length`和`Transfer-Length`两个字段，前者是知道请求返回数据的长度，后者是不知道返回的数据，如果后者的值为`Chunk`的话，当请求的包的长度为0的时候，便说明一次`HTTP`连接结束。

##### 2）字段

- `Keep-Alive`：有`max`和`timeout`，分别代表着最大连接数和超时时间。
- `Connection`：有`close`代表关闭，和`Keep-Alive`代表保持连接。

##### 2.TCP Keep-Alive

​	`TCP`的`Keep-Alive`表示保持存活，因为`TCP`是不会知道引用层的内容的，只能由应用层来进行打开。而有这个字段的话，在`TCP`中会不断发送心跳包，如果对方已经关闭了，就不会有任何响应。这样就会关闭TCP连接。

### 2.HTTPS

#### 默认端口

HTTPS的默认端口是443

#### 与HTTP的区别

HTTPS是为了解决HTTP存在的安全性问题，所以我们先讲一下HTTP存在的安全问题。

1. 明文传输，这是最大的问题
2. 无法验证服务器的身份，因此可能被伪装。
3. 无法检验传输内容是否被篡改过

接下来讲一下HTTPS针对于上述存在的问题的解决方式：

HTTPS协议在运输层和应用层之间有一层加密协议层，由SSL或者TLS组成，这一层的功能有三个：

- 加密传输：将明文加密成密文
- 校验机制：检验传输的数据是否被篡改过
- 身份验证：配置验证证书

##### 1.加密

HTTPS的加密采用非对称加密匹配堆成加密的方式。

- 非对称加密：在开始进行加密的操作的时候，先进行对称加密秘钥的协商。具体流程是首先服务端选择一种非对称加密算法，将公钥发送到客户端（自己存放私钥）。客户端首先生成随机字符串，用公钥进行加密，然后传输到服务端，服务端通过私钥进行解密，得到的结果就是作为对称加密的秘钥。
- 对称加密：在传输数据的时候通过协商得到的秘钥进行加密传输。

特点：

- 秘钥动态生成，可以大大减少被破解的可能。

##### 2.身份验证

HTTPS需要进行配置身份验证，由比较高安全性的中间商进行颁发证书。具体身份认证流程如下：

通常使用Web的时候使用单向验证的方式，那么就讲一下单向验证的整体流程：

1. 浏览器发送验证的SSL版本等信息
2. 服务端返回SSL证书
3. 浏览器请求CA进行验证是否过期等等。
4. 发送可支持的秘钥方式给服务端，服务端选择安全性等级最高的算法给客户端，并且携带公钥
5. 客户端随机生成字符串使用公钥进行加密，传回服务端
6. 服务端使用私钥进行解密，这就是传输数据的对称加密算法秘钥。接下来就是加密的流程。

##### 3.校验传输数据是否被篡改

虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 **MD5** 和 **SHA-1** 等**散列值校验**的方法，以及用来确认文件的**数字签名**方法。

提供文件下载服务的 Web 网站也会提供相应的以 PGP（Pretty Good Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。**PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值**。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。

数字签名：使用**私钥**进行加密，使用公钥进行**解密**。

##### 4.HTTPS的四次握手

![img](../../../../%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PersonNote/%E9%9D%A2%E7%BB%8F/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6/images/2718191-e2a6b0a921c93075.webp)

1. 浏览器（客户端）随机数字，发送到服务端，并且发送ssl/tls版本等信息（第一次握手）
2. 服务端通过ssl/tls等信息，选择安全度最高的算法， 并且产生随机数。最后连同公钥发送给客户端（第二次握手）
3. 客户端接收到数字证书等信息，去验证是否过期。然后生产成随机字符串，然后将字符串通过公钥加密一起发送到服务端。
4. 最后客户端通过字符串+客户端随机数+服务端随机数根据加密算法进行加密。服务端也是这么加密。这样就要有了对称加密的秘钥。

###### 问：https四次握手就不需要TCP三次握手了嘛？

不，还是需要的，TCP三次握手的目的是保证打开服务器端口，从而进行传输数据。而https是在应用层面的握手。还是需要先进行TCP握手才能传输数据。

### HTTP1.1和HTTP2的比较

#### 1.多个请求共享同一个TCP连接机制

- HTTP1.1中多个请求共享TCP连接的话，是串行共享的，也就是前面的请求没有结束，后面的并不会开始
- HTTP2是采用并行策略，实现多路复用，然后根据不同的包的头部进行拼装，这样不会出现前面阻塞后面就不会开始的情况。**同个域名只需要一个TCP连接，而且不同的HTTP请求会有优先级别**

#### 2.数据流格式

- HTTP1.1的数据流是以文本为数据流的形式，以特定的符号进行分割不同的内容。
- HTTP2则是采用二进制分帧形式，消息由一个帧或者多个帧组成，服务器解析起来更快速。

#### 3.是否支持服务器主动推送

- HTTP1.1不支持
- HTTP2支持

#### 4.头部压缩

- HTTP1.1每次请求都会带所有的头部
- HTTP2每次请求的头部只会发送那些更改了的头部，并且会根据算法进行压缩头部。

### TCP

特点：

- 面向连接
- 面向字节流
- 具有拥塞控制
- 提供可靠服务

拥塞控制：

- 慢开始：拥塞窗口一开始设置成1，然后发送成功就会翻倍，成指数增长
- 拥塞避免：当拥塞窗口大于慢开始门限的时候，会变成线性增长，使用拥塞避免
- 快重传：如果对于同一报文的确认ack收到3个，则使用快重传算法，发送对应报文段。并且执行快恢复
- 快恢复：慢开始门限与拥塞控制窗口设为拥塞窗口的一半，并且使用拥塞避免。

### UDP

- 提供尽可能的，不保证可靠的传输
- 面向报文体，即应用层下来的是UDP报文
- 不存在拥塞控制
- 头部比较小
- 面向无连接

#### UDP如何提供可靠服务？

- 具有超时重传机制
- 发送的报文具有序号，这样就能够保证给到的报文正确组装
- 具有应答机制：即seq和ack前者是当前序列号，后者是期望收到的序列号
- 具有滑动窗口等

