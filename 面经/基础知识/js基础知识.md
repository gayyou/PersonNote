# JS的基础知识

[TOC]

### 1.对象篇

##### new操作符中构造函数中执行了什么？

1. 创建一个新的Object
2. 将新的Object的原型设为构造函数的原型，新的Object的constructor设为构造函数
3. 将构造函数当做普通函数，然后把执行上下文对象设为新创建出来的对象
4. 如果构造函数返回的是基本数据类型，那么返回this，如果是引用数据类型的话，则返回引用的数据类型。

##### ES6的类和ES5构造函数的区别

1. ES6的类只能被new字符来进行，不能当做普通函数执行；但是ES5则可以
2. ES6类的原型上的属性不可被枚举，但是ES5构造函数的原型属性上能够被枚举
3. ES6函数不存在声明的提升，；但是ES5存在声明的提升，也就是可以先使用后声明
4. ES6可以在类中定义类的静态属性；ES5只能对构造函数增加属性，定义静态属性和方法。
5. ES6可以通过new.target来判断执行的构造函数，可以使某些父类不能被实例化；而ES5只能通过其他方式来进行判断。可以通过this.constructor来进行判断。
6. ES6的继承是先在constructor调用super来执行父类的构造器来，然后返回新创建的实例（这个实例是子类的），然后再进行执行子类构造器来修改this（最后是子类），并且如果不调用super的话是不能使用this的。ES5则是先创建子类this，然后再通过执行父类构造器对this进行修改。

### 函数式编程篇

##### 什么是闭包？闭包的作用是什么？

闭包：有权访问其他局部作用域（函数）一次执行结果内部的自由变量就叫做闭包（即执行函数的时候引用了不是自己作用域链内的数据就是闭包）

闭包三要素：函数、自由变量、执行环境（也就是上下文）

闭包的作用：

- 设置保护性缓存，也就是设置一个缓存只能通过某种函数去访问

  ```js
  function cache(fn) {
    let cache = {};
    return (...key) => {
      let result = null;
      
      if (cache[key]) {
        result = cache[key];
      } else {
        cache[key] = (result = fn(...key));
      }
      
      return result;
    };
  }
  ```

- 设置私有变量

  ```js
  let _privateVar = Symbol();
  class A {
    getName() {
      return this[_privateVar];
    }
    setName(value) {
      this[_privateVar] = value;
    }
  }
  ```

- 函数防抖

  ```js
  function debounce(fn, time) {
    let timer = null;
    
    return (...args) => {
      if (timer) {
       	clearTimeout(timer);
        timer = null;
      }
      setTimeout(fn, timer, ...args);
    };
  }
  ```

- 单例模式的函数式构造方法

  ```js
  function singleFactory(constructor) {
    let obj = null;
    
    return function(...args) {
      return obj ? obj : obj = new constructor(...args);
    }
  }
  ```

### var、let、const的区别

- var
  - 在全局作用域中声明，会挂载到window对象上面
  - 存在变量声明的提升
  - 不存在块级作用域
- let
  - 是var的升级版，有用块级作用域
  - 不存在变量声明的提升
  - 不可重复声明
- const
  - 声明的时候要进行赋值
  - 值不能够改变，js中，变量指向的是存储数据的指针，所以const存储的指针不能够进行改变。

### AO/VO

首先说明一下AO和VO的含义

- AO：Activive Object，即函数的活动对象。
- VO：Variable Object，即变量对象。

它们的作用是帮助js引擎在引用变量的时候能够去顺利找到变量。并且它们之间的联系可以实现作用域链。

#### VO

在执行函数的时候，会经历执行上下文的创建和代码的执行。如下图。

![EC-LIFE](../../../../%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PersonNote/%E9%9D%A2%E7%BB%8F/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/15feb926b8af7f88-1582013398780)

我们会先进行上下文的创建，创建VO、通过`[Scope]`属性指向外层的`VO`来进行指向外层的AO对象，那么这样就形成了作用域链。接下来是this的指向问题。

在创建VO对象的时候，会先把所有变量的声明放到一个对象属性上,但是他们的属性为空，所以这就是**变量的提升**。

所以简单来说。VO的作存储用就是存储变量，然后本代码或者子代码在执行的时候能够知道变量的值。并且变量定义的顺序如下：

- 参数
- 变量
- 函数

#### AO

AO和VO的关系：

**AO可以理解为VO的一个实例，也就是VO是一个构造函数，然后VO(Context) === AO**，所以VO提供的是一个函数中所有变量数据的模板。

对于同一个函数分多次执行，那么里面的变量、形参和定义的函数肯定是不同的函数，所以每次执行都会产生一个AO对象，即**VO是AO的一个实例**，但是这个实例并不是new 出来的，而是在同一段执行代码执行的时候放进来的。

1. VO是不能访问的(除了全局上下文的VO可以间接访问)，但是**可以访问AO的成员**(属性)。
2. VO和AO其实是一个东西，只是处于不同的执行上下文生命周期。AO存在于执行上下文位于执行上下文堆栈顶部(就是上边说的'当控制进入函数代码的执行上下文时')的时期。再粗暴点，就是**函数调用时，VO被激活成了AO**。
3. AO通过函数的arguments属性初始化，其值是一个ArgObj，包括 callee、length、arg属性。其中arg属性就相当于下标,比如第一个参数对应arg = 0。

#### 以一个例子来说明

```js
var a = 1;

function A() {
  function B() {
    var b;
  }
  
  B();
}

A();
```

在执行上面代码的时候，首先会进行全局初始化，会执行以下操作

- 初始化环境执行栈

- 初始化全局vo和全局ao，由于全局对象只有一个，所以vo和ao一致。

- 当执行A函数的时候，首先会创建环境变量对象，也就是A函数的VO对象，然后初始化作用域链等

  ```js
  {
    A: {
      [scoped]: VO(G),  // 即AO
      B: <Func>
    },
    G: {
      A: <Func>
      window: G,
      Math: <any>
  	}
  }
  ```

- 外边是一个栈的形式，如果A函数中找不到变量的话，会沿着`scoped`找到Global的AO对象，然后进行查询所需要的变量。

- 要注意到作用域链是词法作用域，跟执行调用关系无关，所以并不是随着上面的栈来进行的，而是通过词法关系来产生的。

- 接下来就是执行B函数

  ```js
  {
    B: {
      [scoped]: VO(A), // 即AO
      b: undefined
    },
    A: {
      [scoped]: VO(G),
      B: <Func>
    },
    G: {
      A: <Func>
      window: G,
      Math: <any>
  	}
  }
  ```

- 为什么`scoped`指向的是AO而不是VO呢？

  上面我们知道VO只是一个模板，由AO实例化，里面B函数执行两遍，本身产生的AO可能不同，但是指向scoped是同一个，也就是上一次执行AO的情况。更形象的在下面

  ```js
  function A() {
    let count = 0;
    return function() {
      console.log(count++);
    }
  }
  ```

  上面个的例子如果把A函数执行两遍，里面的count不会共享，也就是AO对象不同，所以AO就是VO的实例。

  ### ajax

  #### ajax的五种状态：

  - 0为初始化状态，还没有调用send方法
  - 1载入，已经调用send()方法，正在发送请求
  - 2载入完成，已经发送完数据，等待收到相应数据
  - 3交互，正在解析响应内容
  - 4完成：响应内容解析完成，可以在客户端调用。

  #### 状态码

  - 200成功
  - 204没有内容返回
  - 301永久重定向
  - 302临时重定向
  - 304资源没有改变，可以使用缓存
  - 400请求报文出现语法错误
  - 401没有权限，或者认证失败
  - 403请求被服务器拒绝
  - 404没有找到资源
  - 405请求方法不允许
  - 500服务器出错

### JS数组的原生方法汇总

#### map

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

创建一个副本，这个副本的所有项的值是遍历每一次的执行结果。

#### forEach

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

没有返回值。

#### filter

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

返回值是return不为空或者false的时候的结果

every

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

如果有一个项的返回值为空或者false，那么就返回false

#### some

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

如果存在一个值返回true，那么就返回true

#### reduce

参数列表

- 回调函数
  - 上一次返回的结果
  - 当前项的值
  - 当前下标
  - 原生数组值
- 初始值

与上面几个不同，要注意一下。当前返回的值是下一项的pre参数，最后的返回值则是拿到的结果。

### 异步任务

参考Vue中的NextTick的实现，我们可以知道JS的异步任务有如下：

- setTimeout/setInterval：宏观定时器，异步操作

- Promise：ES6的异步操作

- MutationObserver的监听是异步触发，在所有的DOM操作完成后才触发使回调函数进入微任务队列。

  MutationObserver的用法：

  ```js
  let observer = new MutationObserver(cb);
  let textNode = document.createTextNode(String(1));
  observer.observe(textNode, {
    characterData: true
  });
  textNode.data = String(2);
  ```

### 垃圾回收机制

js实行的是垃圾自动回收机制，在这个机制下，我们所创建的对象等数据都会被js回收掉。

##### 1.新生代和老年代

V8引擎会把js的对象分别放在新生代和老年代，新生代中，是年龄比较新的对象，或者说是比较小的对象。而老年代是年龄比较大，或者说是大对象。所以会将新生代和老年代分离开来。

新生代中存放着两种对象，一种是刚刚诞生的，另外一种是经历过一次垃圾回收机制的。而老年代则是存放年龄比较大的对象或者大对象。对于两个空间的垃圾回收机制是不一致的。

##### 2.主垃圾回收器和辅助垃圾回收器

对于老年代和部分新生代，使用主垃圾回收器，而对于新生代，则使用辅助垃圾回收器。首先针对于新生代的垃圾回收策略。

##### 3.from-space到to-space

新生代使用scavenge算法

新生代等分成两个区域，from和to，每次垃圾回收的时候，都是现在from中标记存活的对象，然后将存活对象复制过去，如果是经历过一次垃圾回收机制的话，那么会放到老年代。复制完成后对换地位，等待下次垃圾回收机制的到来。而如何判断存活的对象，等到后面进行说明。

##### 4.标记清除

老年代使用 Full Mark Compact

对于老年代，由于空间比较大，不适合使用对等划分的方式，而是使用了标记清除，首先是标记阶段，从根开始分析，标记存活的对象，然后将那些死亡的对象进行清除。

##### 5.标记紧缩

对于老年代，如果仅仅是标记清除的话，会产生很多碎片空间，在标记后，将存活的对象紧缩在一端，剩下的就是空闲区域，这样能够很好地提高内存的利用率。

##### 6.如何识别死亡对象

引用计数：会存在循环引用等问题

图的可达性：对于全局对象、声明的变量作为出发点，进行深度遍历并且标记，如果是可以到达的，则说明是存活的，如果不能够到达的，则说明死亡。这样就可以判断是否存活。

##### 7.增量标记

传统的垃圾回收算法，在进行标记清除的过程中，是会暂停所有线程的执行，目的是为了避免在清除的时候又产生垃圾等等，而标记清除正是为了避免这种情况。打个比方，传统垃圾回收机制好比打扫一个屋子，打扫的时候如果放进狗的话，可能永远打扫不完，但是增量标记的话，目的就是为了达到边打扫边产生垃圾的作用。采用的是三色标记。

增量标记是穿插在js执行线程之间，它会保存之前的标记状态，如果用两色标记，那边无法判断某个节点是否扫描了子节点。

如果使用三色标记：黑、白、灰。这样黑色代表本节点已经被标记，子节点也已经被标记，灰色代表本节点被标记，子节点未被标记。白色节点代表未被标记。这样每次只要处理灰色节点即可。并且如果当前不存在灰色节点的时候，可以采用清除策略。

但是还有一个问题，因为在并发环境下，js可能会进行对象的引用的变更，如果一个对象一会儿被黑色节点所引用，一会儿被灰色节点所引用，那么要怎么处理？

解决的话是每次黑色节点指向白色节点的时候，直接将白色节点设为灰色。这样就能避免刚创建的对象被清除。

##### 8.并发

V8的垃圾回收机制并不是只有主线程来进行垃圾回收，而是有很多辅助线程来进行垃圾回收。

### 页面渲染过程

##### 1.解析DOM树

将HTML解析为DOM树

##### 2.解析CSSOM树

将css解析为CSSOM树

##### 3.生成Render树

将DOM树和CSSOM树合并生成渲染树

##### 4.生成layout

依照盒子模型，计算出各个元素在文档流中的大小和位置

##### 5.绘制Paint

根据计算出来的规则，进行显示到页面上。

##### 重排和重绘

重排即重新生成layout，如果一个元素发生改变，影响了其他元素在文档流中的位置，那么就要从这个元素开始进行重新计算，并且绘制。引起重排的原因：

- 改变大小
- 元素被删除
- 改变内容
- 改变位置

重绘是不会影响到其他元素在文档流中的位置，那么不需要进行重新计算，主要的操作有

- 改变背景
- 改变颜色

### 问题集

##### 1.为什么第一次打开页面会慢，之后会快？

- 浏览器缓存：协商缓存和强制缓存
- 还有其他缓存吗？代理服务器缓存、DNS缓存

##### 2.typeof、instanceof、isPrototype的区别

- typeof是检测数据类型，检测基本数据类型和引用数据类型，但是无法区分引用数据类型
- instanceof是进行判断构造函数的prototype是否在对象的原型链上面。
- isPrototype：也是通过判断构造函数是否在某个实例的原型链上

##### 3.call()，apply()的区别

- 两者都是更改作用域对象，前者需要一个一个传入参数，后者只需要传入参数数组即可。

##### 4.eval的作用

- eval如果传进来一个字符串的时候，会当做JavaScript代码来执行，但是传进来的是由JSON.stringify转过来的字符串，就真的当一个字符串使用。
- 如果不是字符串，则会返回这个值。

##### 5.null，undefined或undeclared

- null是一个空指针，预示着这个变量最后会指向一个对象，而不是基本数据类型
- undefined是未定义，表示变量还没有初始化
- undeclared：未声明，该变量还没有声明。

##### 6.\=\=和\=\=\=的区别

- \=\=\=表示恒等于，会进行类型判断，再进行值的比较。如果是一个引用类型的话，跟等同相等都是进行比较指针。

- \=\=表示等同，'12'和12是相等的

  - 对于相同类型数据，和恒等于相同
  - 对于不同的数据类型，如果是基本数据类型，会转为数值然后进行比较，如果是对象数据类型，会转为基本数据类型再进行比较。

  特殊：

  - undefined 和null相等
  - 0和''相等

##### 7.事件代理、委托

- 利用事件冒泡的特点，多个子元素如果具有等同的点击事件，如果都绑定事件，那么必然造成 内存开销。如果把事件绑定到父容器，利用冒泡特性，终究会冒泡到父亲容器，然后产生回调事件，最后通过event.target判断对象内容来进行操作。
- document.addEventListener(type，cb、capture)中第三个如果为false 的话，表示在冒泡阶段获得，如果是true的话，表示在捕获阶段获得。
- 阻止事件冒泡：
  - 如果非ie的话，使用e.stopPropagation()，如果是IE的话，采用cancelBubble，或者直接return false即可。

- 阻止默认行为：
  - 非IE：preventDefault
  - IE：returnValue = false

##### 8.简述一下JavaScript中this的指向

除了箭头函数，其他函数this的指向由运行时候决定的。

- 对于普通函数，函数被谁调用，就指向谁，如果没人引用，那么默认指向window（浏览器环境下非模块化，如果是mjs的话，顶层的this指向undefined，那么就是undefined）。
- 对于构造函数，指向的是新创建的对象，也就是一个空对象。
- 对于类，也是这样，不过类和构造函数有点小小的区别，这里就不提了。
- 对于绑定作用域的，如bind、call、apply等，就会绑定在第一个函数中。

##### 9.基本数据类型和引用数据类型

- 基本数据类型：number、string、boolean、undefined、null、Symbol
- 引用数据类型：Object、Date、Map、Set等等

##### 10.继承讲解

##### 11.对象创建

##### 12.说明一下下列函数为什么不是IIFE（立即执行函数）

```js
function foo(){
    //code
}()
```

以function开头的会解析成函数声明，函数声明是无法直接执行的，只需要将函数声明作为一个单独的语句，即添加()即可执行

```
(function foo(){
    //code
})()
```

##### 13.详尽的介绍一下ajax

- 相比于表单提交，ajax是浏览器中进行异步请求的方法。在请求过程中，js线程能够执行其他事情，等到返回数据的时候进行回调。

- ajax有五种状态码，分别是0,1,2,3,4。

  - 0：初始化请求对象成功
  - 1：开始发送数据
  - 2：发送数据成功
  - 3：开始接受数据
  - 4：接收数据完成

  ajax有onreadystatechange事件，即状态改变后的事件，第一个参数的是状态事件，当onreadystatechange为4的时候，可以获取数据，首先要判断event.code === 200。然后获取responseText数据，最后获取数据。

- 优点：

  - 异步不需要更新
  - 支持前后端分离
  - 减少后端压力，后端只需要返回数据即可

- 缺点：

  - 浏览器机制遭受破坏。以往想看之前数据，返回即可。
  - 安全性问题
    - 跨站点脚本攻击
    - sql注入等等

##### 14.get和post的区别

- 浏览器上get参数长度限制，而post不会，这是因为get参数放在url上。
- get是简单请求，简单请求是不会触发跨域问题的，而post是复杂请求，需要处理跨域问题。
- get请求只能放ascII码而post不需要，这是因为url只支持ascII，中文需要转义。

##### 15.什么是简单请求、什么是复杂请求？

简单请求：

- 请求类型是如下：
  - Head
  - Get
  - Post
- 请求头部不超出如下请求：
  - Accept
  - Accept-language
  - Content-language
  - Content-type：Text/Plain、x-www-urlencoded、form-data

其他请求就是复杂请求。

复杂请求会首先发一个OPTIONS请求来，用来判断请求资源是否安全。返回成功的时候再发送请求。

##### 16.请解释一下变量声明的提升

变量声明的提升的表现是变量可以先使用，后声明。这是一位js的作用域存在变量对象和活动对象。

作用域初始化的时候，首先创建一个VO对象，这个对象对本函数中所有变量声明放在这个对象中，里面的值是空的。然后会有一个[scope]属性，指向外部作用域的AO对象。这样就是作用域链的原理。然后函数执行的时候，会有一个上下文，通过这个上下文来常见AO对象，所以AO对象是VO对象的一个实例。即每次执行的时候，AO都是不同的。在内部寻找变量的时候，都是通过AO来直接寻找，这是针对于var而言的。变量声明的提升包括普通变量和var，顺序为

- 参数
- var
- 函数

并且具有后来者居上的原则。

##### 17.window.onload事件和document.DOMContentLoaded事件的区别

- DOMContentLoaded事件是文档加载结束

- window.onload事件是所有资源加载完毕

- jq的ready是监听document.onreadystatechange为complete的时候进行调用。

  具体是首先监听document.onreadystatechange,然后里面进行判断document.readystate是否为complete

##### 18.怎么获取url的参数

```js
function getParam(url) {
  let paramStrArray = url.split('?');
  let paramStr = paramStrArray[paramStrArray.length - 1];
  
  let resultObj = {};
  
  paramStr.split('&').forEach(item => {
    let itemArr = item.split('=');
    resultObj[itemArr[0]] = itemArr[1];
  });
  
  return resultObj;
}
```

##### 19.Arguments到底是什么

每个函数执行的时候都有一个Arguments对象，存放着本次调用传进来的所有参数，并且这个对象有一个callee，表示调用者，它是一个类数组，即像数组拥有下标和length属性，但是原型链上没有Array的原型，所有它没有数组的很多方法，所以叫做类数组。

##### 20.new 方法内部做了什么？

- 创建一个空的对象
- 将这个对象的原型指向构造函数的prototype
- 将这个对象的构造函数指向构造函数
- 用这个对象作为执行环境对象进行执行函数
- 如果返回的是一个普通数据类型，返回这个对象，否则返回引用数据类型。

##### 21.fetch是什么？

fetch是JavaScript提供的区别去XMLHTTPRequest之外的接口，是一个Promise请求。与传统的ajax请求相比，有如下特点：

1. 是由Promise处理的，只要成功发出请求，就执行resolve，如果是发不出请求，那么会执行reject
2. 不会接受跨域的cookie，即后端设置的set-cookies是会被忽略的。
3. 默认是不支持跨域，想要跨域的话，需要设置credentials字段为true

缺点：

1. 目前还没有超时控制
2. 无法原生监听进度

##### 22.首屏白屏是什么？如何处理vue的首屏白屏

由于Vue是由js来渲染的，所以页面的显示需要等到js文件加载完毕的时候再进行渲染，在下载js文件的时候，屏幕什么也不会渲染。

处理：

- 使用异步组件+代码分割
- 服务端渲染
- loading或者骨架屏
- 使用CDN加速，即将静态资源放到CDN上，用户会向就近的CDN进行申请下载资源。
- 进行缓存处理
- 如果是开头需要用到CPU密集型，那么适当使用Web Worker

##### 23.如何实现浮点数精确运算

- 浮点数运算产生错误的原因是两个浮点数运算后，超出部分会被阶段，造成运算结果出错

- 思路是利用整数的运算是不会产生错误的，先把浮点数转为字符串，记录小数点位数
- 然后去除小数点，进行运算
- 最后再根据小数点来转为相应的浮点数

##### 24.使用构造器判断类型的缺点是什么？

1. 构造器能够被修改
2. Null和undefined无法判断。

##### 25.in操作符和hasOwnProperty操作符的区别？

1. in是判断是否在目标对象的属性以及原型链上出现
2. hasOwnProperty是判断属性是否是目标本身的属性

##### 26.获得原型的方法

1. getProtypeOf
2. instance.\_\_proto\_\_
3. instance.constructor.prototype

##### 27.拖拽丢失怎么解决？

产生原因：

1. 浏览器的drag事件

   drag事件会屏蔽掉mousemove和mouseup，所以drag会导致拖拽丢失。

2. 离开目标节点的时候

   当鼠标离开容器的时候，会触发mouseleave事件，导致mouseup事件丢失，那么解决办法就是在mouseleave事件中解除拖拽事件。

##### 28.mouseout、mouseover和mouseleave、mouseenter的区别

- 前两者子元素会有作用，即如果进入子元素，那么就会产生mouseout，从子元素进入父元素，那么会产生mouseover
- 后者不会对子元素有连带作用。

##### 29.如果可视化编程平台使用事件委托的话，要怎么处理才能做到事件委托

- 都设置到svg标签上，只要离开标签就进行适当的处理。

##### 30.

