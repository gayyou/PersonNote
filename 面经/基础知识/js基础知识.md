# JS的基础知识

[TOC]

### 1.对象篇

##### new操作符中构造函数中执行了什么？

1. 创建一个新的Object
2. 将新的Object的原型设为构造函数的原型，新的Object的constructor设为构造函数
3. 将构造函数当做普通函数，然后把执行上下文对象设为新创建出来的对象
4. 如果构造函数返回的是基本数据类型，那么返回this，如果是引用数据类型的话，则返回引用的数据类型。

##### ES6的类和ES5构造函数的区别

1. ES6的类只能被new字符来进行，不能当做普通函数执行；但是ES5则可以
2. ES6类的原型上的属性不可被枚举，但是ES5构造函数的原型属性上能够被枚举
3. ES6函数不存在声明的提升，；但是ES5存在声明的提升，也就是可以先使用后声明
4. ES6可以在类中定义类的静态属性；ES5只能对构造函数增加属性，定义静态属性和方法。
5. ES6可以通过new.target来判断执行的构造函数，可以使某些父类不能被实例化；而ES5只能通过其他方式来进行判断。可以通过this.constructor来进行判断。
6. ES6的继承是先在constructor调用super来执行父类的构造器来，然后返回新创建的实例（这个实例是子类的），然后再进行执行子类构造器来修改this（最后是子类），并且如果不调用super的话是不能使用this的。ES5则是先创建子类this，然后再通过执行父类构造器对this进行修改。

### 函数式编程篇

##### 什么是闭包？闭包的作用是什么？

闭包：有权访问其他局部作用域（函数）一次执行结果内部的自由变量就叫做闭包（即执行函数的时候引用了不是自己作用域链内的数据就是闭包）

闭包三要素：函数、自由变量、执行环境（也就是上下文）

闭包的作用：

- 设置保护性缓存，也就是设置一个缓存只能通过某种函数去访问

  ```js
  function cache(fn) {
    let cache = {};
    return (...key) => {
      let result = null;
      
      if (cache[key]) {
        result = cache[key];
      } else {
        cache[key] = (result = fn(...key));
      }
      
      return result;
    };
  }
  ```

- 设置私有变量

  ```js
  let _privateVar = Symbol();
  class A {
    getName() {
      return this[_privateVar];
    }
    setName(value) {
      this[_privateVar] = value;
    }
  }
  ```

- 函数防抖

  ```js
  function debounce(fn, time) {
    let timer = null;
    
    return (...args) => {
      if (timer) {
       	clearTimeout(timer);
        timer = null;
      }
      setTimeout(fn, timer, ...args);
    };
  }
  ```

- 单例模式的函数式构造方法

  ```js
  function singleFactory(constructor) {
    let obj = null;
    
    return function(...args) {
      return obj ? obj : obj = new constructor(...args);
    }
  }
  ```

### var、let、const的区别

- var
  - 在全局变量中声明，会挂载到window对象上面
  - 存在变量声明的提升
  - 不存在块级作用域
- let
  - 是var的升级版，有用块级作用域
  - 不存在变量声明的提升
  - 不可重复声明
- const
  - 声明的时候要进行赋值
  - 值不能够改变，js中，变量指向的是存储数据的指针，所以const存储的指针不能够进行改变。

### AO/VO

首先说明一下AO和VO的含义

- AO：Activive Object，即函数的活动对象。
- VO：Variable Object，即变量对象。

它们的作用是帮助js引擎在引用变量的时候能够去顺利找到变量。并且它们之间的联系可以实现作用域链。

#### VO

在执行函数的时候，会经历执行上下文的创建和代码的执行。如下图。

![EC-LIFE](../../../../%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PersonNote/%E9%9D%A2%E7%BB%8F/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/images/15feb926b8af7f88-1582013398780)

我们会先进行上下文的创建，创建VO、通过`[Scope]`属性指向外层的`VO`来进行指向外层的AO对象，那么这样就形成了作用域链。接下来是this的指向问题。

在创建VO对象的时候，会先把所有变量的声明放到一个对象属性上,但是他们的属性为空，所以这就是**变量的提升**。

所以简单来说。VO的作存储用就是存储变量，然后本代码或者子代码在执行的时候能够知道变量的值。并且变量定义的顺序如下：

- 参数
- 变量
- 函数

#### AO

AO和VO的关系：

**AO可以理解为VO的一个实例，也就是VO是一个构造函数，然后VO(Context) === AO**，所以VO提供的是一个函数中所有变量数据的模板。

对于同一个函数分多次执行，那么里面的变量、形参和定义的函数肯定是不同的函数，所以每次执行都会产生一个AO对象，即**VO是AO的一个实例**，但是这个实例并不是new 出来的，而是在同一段执行代码执行的时候放进来的。

1. VO是不能访问的(除了全局上下文的VO可以间接访问)，但是**可以访问AO的成员**(属性)。
2. VO和AO其实是一个东西，只是处于不同的执行上下文生命周期。AO存在于执行上下文位于执行上下文堆栈顶部(就是上边说的'当控制进入函数代码的执行上下文时')的时期。再粗暴点，就是**函数调用时，VO被激活成了AO**。
3. AO通过函数的arguments属性初始化，其值是一个ArgO，包括 callee、length、arg属性。其中arg属性就相当于下标,比如第一个参数对应arg = 0。

#### 以一个例子来说明

```js
var a = 1;

function A() {
  function B() {
    var b;
  }
  
  B();
}

A();
```

在执行上面代码的时候，首先会进行全局初始化，会执行以下操作

- 初始化环境执行栈

- 初始化全局vo和全局ao，由于全局对象只有一个，所以vo和ao一致。

- 当执行A函数的时候，首先会创建环境变量对象，也就是A函数的VO对象，然后初始化作用域链等

  ```js
  {
    A: {
      [scoped]: VO(G),  // 即AO
      B: <Func>
    },
    G: {
      A: <Func>
      window: G,
      Math: <any>
  	}
  }
  ```

- 外边是一个栈的形式，如果A函数中找不到变量的话，会沿着`scoped`找到Global的AO对象，然后进行查询所需要的变量。

- 要注意到作用域链是词法作用域，跟执行调用关系无关，所以并不是随着上面的栈来进行的，而是通过词法关系来产生的。

- 接下来就是执行B函数

  ```js
  {
    B: {
      [scoped]: VO(A), // 即AO
      b: undefined
    },
    A: {
      [scoped]: VO(G),
      B: <Func>
    },
    G: {
      A: <Func>
      window: G,
      Math: <any>
  	}
  }
  ```

- 为什么`scoped`指向的是AO而不是VO呢？

  上面我们知道VO只是一个模板，由AO实例化，里面B函数执行两遍，本身产生的AO可能不同，但是指向scoped是同一个，也就是上一次执行AO的情况。更形象的在下面

  ```js
  function A() {
    let count = 0;
    return function() {
      console.log(count++);
    }
  }
  ```

  上面个的例子如果把A函数执行两遍，里面的count不会共享，也就是AO对象不同，所以AO就是VO的实例。

  ### ajax

  #### ajax的五种状态：

  - 0为初始化状态，还没有调用send方法
  - 1载入，已经调用send()方法，正在发送请求
  - 2载入完成，已经发送完数据，等待收到相应数据
  - 3交互，正在解析响应内容
  - 4完成：响应内容解析完成，可以在客户端调用。

  #### 状态码

  - 200成功
  - 204没有内容返回
  - 301永久重定向
  - 302临时重定向
  - 304资源没有改变，可以使用缓存
  - 400请求报文出现语法错误
  - 401没有权限，或者认证失败
  - 403请求被服务器拒绝
  - 404没有找到资源
  - 405请求方法不允许
  - 500服务器出错

### JS数组的原生方法汇总

#### map

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

创建一个副本，这个副本的所有项的值是遍历每一次的执行结果。

#### forEach

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

没有返回值。

#### filter

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

返回值是return不为空或者false的时候的结果

every

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

如果有一个项的返回值为空或者false，那么就返回false

#### some

参数列表

- 回调函数
  - 数组当前值
  - 数组当前下标
  - 数组引用
- 回调this的指向

如果存在一个值返回true，那么就返回true

#### reduce

参数列表

- 回调函数
  - 上一次返回的结果
  - 当前项的值
  - 当前下标
  - 原生数组值
- 初始值

与上面几个不同，要注意一下。当前返回的值是下一项的pre参数，最后的返回值则是拿到的结果。

### 异步任务

参考Vue中的NextTick的实现，我们可以知道JS的异步任务有如下：

- setTimeout/setInterval：宏观定时器，异步操作
- Promise：ES6的异步操作
- MutationObserver的监听是异步触发，在所有的DOM操作完成后才触发使回调函数进入微任务队列。

### 问题集

##### 1.为什么第一次打开页面会慢，之后会快？

- 浏览器缓存：协商缓存和强制缓存
- 还有其他缓存吗？代理服务器缓存、DNS缓存