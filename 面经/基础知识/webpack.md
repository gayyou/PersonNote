# Webpack的实现原理

[TOC]

### 基本概念

1. Entry：入口，webpack构建入口。
2. module：webpack中一个模块对应一个文件，其实是利用node的模块化。
3. chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并与分割
4. loader：模块转换器，用于将模块的内容转换成新的内容
5. plugin：拓展插件。

#### loader和plugin的区别

1. loader：相当于一个转换器，将A文件转为B文件，loader让webpack能够处理不同的文件，loader将所有类型的文件通过转换规则转换成webpack能够处理的文件，然后webpack进行打包操作。
2. plugin：执行一些打包、优化压缩等等操作。

#### 实质

webpack的实质是一个Node程序。

#### Webpack的执行流程

1. 初始化入口，然后将用户配置的webpack配置项和shell命令进行合并，然后得到编译的参数
2. 创建编译实例
3. 从入口出发，用loader对文件进行编译，然后获取文件所引用的模块，进行递归编译
4. 完成编译模块后，得到每个模块被翻译之后的内容和他们对应的引用关系以及依赖关系
5. 输出资源，根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将chunk转为单独的文件
6. 输入完成后，根据配置确定输出路径和文件名，然后用fs将文件输出到系统中。

### 基本用法

##### 1.入口(entry)

```json
// entry选项可以用两种方式来使用
entry: 'path'  // 这种处理只有一个模块的方式

// 这种处理多个文件入口的模式，每个文件都会进行独立的处理，最后处理成不同的文件输出
entry: {
  app1: '',
  app2: ''
}
```

最后会处理成为相应的出口文件，不过如果是进行代码分割的话，遇到相同的模块会共享同一份代码。

##### 2.出口(output)

```json
output: {
    // 输出路径
    path: path.resolve(__dirname, './dist'),
    // 输出文件名称
    filename: '[name]-[hash].js'   // name代表着入口文件模块，hash代码着hash后缀
}
```

##### 3.mode

##### 4.使用source map

对于webpack处理后的文件，模块将模块处理成为字符串，在初始化的时候使用eval进行进行解析成为模块，如果使用

`devtool: "inline-source-map"`的时候，会将代码以源码的形式展示出来，此时有利于debug

##### 5.使用观察模式来进行实时打包

`webpack --watch`命令开启观察打包模式，在这个模式下，对webpack文件进行修改会触发webpack的打包功能，不过这种是直接打包的，我们需要刷新浏览器才能够看到效果，接下来介绍的是使用热更新，如果发生了修改会自动刷新页面。

##### 6.使用服务器来适用于开发环境

`npm install webpack-dev-server`命令安装开发环境服务器。通过使用命令

`webpack-dev-server --open`命令开启热更新模块。热更新模块的思路是将文件处理完毕后，先不处理成为文件，而是在内存中。通过node开启本地服务器，网页访问数据的时候，服务器直接将内存中的数据返回给浏览器即可。

如果热更新的时候，需要进行声明，如下：

- `module.hot.accept`：代表模块执行热更新
- `module.hot.decline`：当前模块更新时候一定要刷新页面

### 热更新模块



