# 可视化编程机器人问题

### 1.基础问题

1. 根据代码嵌套结构设计存储数据结构，这个存储数据结构长什么样子？

   答：这个数据结构整体来看，是一棵树状结构。是以一个纯对象来进行实现，然后对象的键值是定义好的代码块名称，然后键值是一个数组，存放着这个容器具某种代码块的所有实例。而代码块的话，根据普通语句和判断循环语句，划分成两种：容器代码块和普通代码块。容器代码块也是具有子树结构，所以可以无限嵌套下去。

2. 接口数据类型长什么样子？

   答：接口数据类型是以代码三种形式：顺序、循环、判断来设计的，最外层是一个数组，然后数组的元素都是对象，并且格式相同的，有type是来表示语句的类型，如果是函数调用则是func，如果是判断语句，则是if、如果是循环语句则是while，然后判断语句和循环语句都有孩子。

3. vue中为对象新增属性是不会触发相应数据的，你是怎么做到只关注数据就可以操纵代码块

   主要问题出现在容器内部，容器内部也是具有其他元素的引用的，然后传进来数据会被新建的容器所观察，所以能够实现深度嵌套也有数据响应。

4. 你是如何做到只关注数据即可对代码块进行操作的？

   首先要确定是svg矢量图，他是以html标签，也就是dom节点渲染到页面上的。所以代码块之间的嵌套关系可以用树状结构的嵌套关系来表示，所以我能用树状结构代表代码的嵌套关系。同时，我将这些html标签的一些属性都放到这棵数据树的节点内容中，然后我可以利用Vue的数据响应系统，对数据进行改变的时候会更新到视图层上面。

5. 如何实现数据压缩的？

   这个平台有个功能是存储用户所进行的提交，一开始我们是打算用另外一个接口直接把数据放进去就行了，但是发现这样不是很讲究。后来发现接口数据中代表代码块的执行顺序是依靠json的数组顺序来的，所以在转为json数组的时候，根据代码块的y坐标来定义决定它的执行顺序。而反过来也是这样进行的。

6. 为什么用svg，其他不行吗？

   svg是渲染在dom树上的，并且能够通过修改值来改变大小，比如说if语句中的高度会随着容纳元素的增加而增加，此时只能够通过svg才能够实现。

7. 了解过其他组件库吗？

   有一个blockly，是国内外很多编程平台使用到的插件，一开始我也在考虑是否使用它，但是后来觉得不妥：

   1.后面怎么根据代码获取json格式数据，显然要看源码，这个总体设计到到完成，只有15天时间，显然没有时间去研究源码。

   2.如果使用插件的话，成长空间很局限，觉得要挑战一下自己。

8. 拖拽模块是怎么实现的？

   利用鼠标的三个点击事件：mousedown，mousemove、mouseup。在mousedown的时候记住元素的位置、mousemove的时候使用dom操作修改元素的位置，这是整个项目中直接对dom进行操作的地方，在mousedown的时候修改数据。

9. 函数的整个流程是怎么样的？

   首先用户进行拖动代码块，就通过拖拽模块进行处理，然后拖拽结束后，进入碰撞检测。如果检测成功，则进行数据的转移。转移结束后，再进行调整代码块，使得代码按正确顺序嵌套（调整代码块模块模块可以复用到接口转为数据结构中）。

### 2.SVG语法有哪些？能说说吗？

##### 1.大写是绝对坐标

每次进行操作的时候，会将光标移动到目的地。

1. M从a坐标移动到b坐标，并不会进行任何绘制工作。
2. L从a坐标到b坐标绘制一条直线
3. H绘制水平线，然后后面一个参数是坐标点，是横坐标的位置，所以是绘制。
4. V绘制垂直线，正的代表向下，负的代表向上。
5. Z从当前位置到起始位置绘制一条线。

##### 2.小写是相对坐标，其他都一样。

##### 3.如何实现线条流动效果

使用dashArray还有dashoffset来进行绘制

- dashArray是线条分段的长度，只需要设置一个，然后设置位线条的总长度就好了。
- dashoffset是当前线条的长度，我们需要修改它的值，从而实现流动的效果

### 3.你是怎么说服你队友让你从0开始实现这个东西？

1. 说服队友的话，无非是让队友相信两件事：我能做这件事，这件事是能做的。
2. 这件事是能做的：即技术可行，那么我这边的做法是先找出实现的关键点：1.svg的嵌套；2.svg形状的改变。
3. 我能做这件事情：拿之前在短时间内学习并且做过一个排插小程序。

### 4.性能问题

拖拽模块的性能问题，无非从以下几点来进行考虑。

1. DOM节点的操作

   Vue的Virtual DOM已经对渲染进行优化，即对于一个渲染函数的执行，会进行深度优先遍历，从而在最后只需要挂载一次，避免多次渲染元素在页面上，减少渲染开支。这是框架已经帮我们实现的了。

   在拖拽过程中只对dom进行操作，然后在拖拽结束后再更新数据，这样在拖拽过程中就没有必要触发数据响应系统

2. 存储结构的遍历

   由于存储结构是一棵树，并且这棵树并不是平衡树，所以每次更改数据的时候需要进行深度遍历操作，时间复杂度是O（n）。

   每个数据节点都会有一个id，来唯一标识该数据。

   我所想到的能优化的点有两个：

   - 拖拽后修改数据，怎么进行快速定位数据？

     一开始是想着维护一个平衡树来将查询的时间复杂度换成O(logN)，不过后面发现每次需要进行更新节点的信息的话，是在拖拽后进行更新的。事件有个target，指向拖拽目标dom节点。而dom节点也是一个对象。那么在创建组件的时候，将该组件所对应的树的节点的引用设置在dom标签的某个属性上，那么就不需要去创建一棵树状结构，也不需要O(N)的时间复杂度。

3. 节点样式改变导致dom的回流重绘

   很明确一点，在svg画板上的所有标签默认都是类似于绝对定位的，并不存在流的概念。并且修改svg的时候只是修改transfrom，并不会发生svg元素的重新绘制。

### 5.碰撞检测方法

1. 轴对称包围盒，即无旋转的矩形检测

   对于两个同样是矩形的块，判断两个块是否碰撞是通过横纵坐标+宽高来进行判断的。最普通的碰撞检测，这也是这个项目进行碰撞检测的基础。

   缺点：

   - 两者必须是矩形才能进行
   - 由于鼠标移动的时候产生的事件是离散的，所以拿到的偏移坐标如果比较大，那么会发生检测不出来的可能。

2. 圆形检测

   通过计算两个圆心之间的距离是否大于两者半径之和来判断。

   缺点：

   - 两者必须是矩形才可以进行判断
   - 由于鼠标移动的时候产生的事件是离散的，所以拿到的偏移坐标如果比较大，那么会发生检测不出来的可能。

3. 圆形与矩形（无旋转）

   以矩形为固定，然后通过判断圆心在矩形的某个边的关系来进行判断。

   - 若圆心的y轴在矩形的上边框和下边框之间
     - 如果圆心的x坐标在矩形的左边框和右边框之间，那么圆心在矩形的内部，即碰撞。
     - 如果在左边框之外，那么就判断圆心与左边框的距离是否小于半径。
   - 如果不在矩形的上下边框之间，那么判断理圆心最近的点的距离是否小于半径即可。

4. 圆形与旋转矩形（原地旋转）

   矩形的旋转可以看作是整个画布在逆着旋转，而矩形不旋转。旋转圆心在矩形对角线交点。这样就转为无旋转的矩形和圆形是否碰撞。