[TOC]

### 1.diff算法

#### 抽象化解释

VNode和真实的DOM节点一一对应，然后diff的算法是在更新VNode的前提下，寻找最小的代价来进行更新。并且这个更新过程是一个递归过程，即如果存在子节点可以复用的话，那么会深度优先遍历子节点，进行利用存在的结点，从而达到整棵树上的资源复用。

#### 整个Diff算法的流程

我们以一个例子来说明一下怎么处理：

```js
// 旧列表
oldCh,oldStart,oldEnd
// 新列表
ch,newStart,oldEnd

A | B | C |
A | E | C | B |
```

diff算法，是一种双指针的算法，从两端向中间遍历。

1. 首先是判断两个首结点或者尾结点是否相同，如果相同，不做任何处理。
2. 其次判断旧的首节点和新的尾结点是否相同，如果相同的话，就要进行元素的迁移，即按照新的结点的位置放好
3. 再者是根据key来建立Map，这样的目的是为了简化后面的寻找时间，如果有Key的话，可以将查询时间看作是1，如果没有map的话，是要在数组里面查找，时间复杂度会是n。
4. 最后如果newCh遍历完了，将old数组其他没有遍历到的元素清除掉
5. 如果oldCh遍历完，将newCh数字其他没有遍历到的元素创建。

在上面过程中，如果在更新的时候，是存在子结点的时候，会进行递归遍历子代的Vnode，然后进行diff算法的更新。这就是整个过程。

#### 问题集

##### 1.key为index和key为id的区别

这是在diff算法里面的不同。首先先确定有没有key的区别，也就是说key的作用

- key的作用：在updateChildren的函数中，如果VNode有key的话，那么可以根据key来构建映射，然后在查询那些不是首尾相同的节点的时候去遍历这个map，会比去遍历数组要快。不过如果有map的话，那么在查找不到数据的时候是不会去遍历数组的，所以就相当于该元素不存在。

再来看看index的key和id的key的区别吧：

- index的key在每次渲染前后（只要数据数量一致），那么新VNode的key和旧VNode的key是相同的，默认是会通过map找到对应的下标，然后进行判断标签名、标签data是否相同。
  - 如果是相同的普通标签，那么会进行标签的复用
  - 如果是相同的组件标签，但是实际上是不同的组件实例的话，data会不同，所以以index为key的话，那么如果在中间插入一个组件实例的话，那么后面的都需要重新渲染。
  - 如果是有状态的普通标签的话，如果是input标签，填写内容后。使用数组的unshift方法，那么上面的内容会显示错乱，也就是说数据会向前偏移1位，这也是因为index的原因，会直接去index找数据，然后会判断是sameNode，然后往最后的进行添加数据。

##### 2.sameNode比较的是什么？

- 首先判断key是否相同（如果没有key，那么也是相同的，因为undefined和undefined也相同）
- 判断标签名是否相同
- 判断data是否相同
- 如果是input标签，那么判断input标签的属性是否相同。

##### 3.一个组件的key发生改变后，会发生什么事情？

分析一下流程

1. 首先key发生改变后，会通过map来进行判断两个组件是否是相同，但是由于key是不同的，则会认为是两个不同的组件实例。
2. 使用diff算法判断发现没有能够复用的组件，那么进行会进行组件的销毁与创建。
3. 接下来是组件的销毁与创建过程。

##### 4.从渲染函数到渲染页面的中间发生了什么事情？

Vue的三大模块，模板编译、数据响应系统、Virtual DOM。

1. 模板编译
2. 数据响应系统
3. Virtual DOM

我们就讲一下模板编译后的渲染函数到生成DOM节点的过程吧。要确定什么时候才会执行渲染函数。有两种情况：

1. 在初始化组件的时候，创建渲染函数观察者的时候，会先执行一遍渲染函数观察者
2. 在更新数据后，触发渲染函数观察者的回调函数执行，会触发Virtual DOM

整个历程如下：

1. 执行渲染函数观察者，返回VNode实例，这个VNode是以组件为单位，而不是产生整个项目的VNode，这样可以实现局部更新。

2. VNode有两大类：一类是普通的DOM。一类是组件。我们使用组件的时候，会使用一个占位符，这个占位符会对应一个VNode，但是现在还不是产生组件或者产生真实的DOM节点的时机。

3. 返回VNode，然后接下来就是打补丁的时候，调用patch函数，接下来就是生成或者更新dom节点的时机。diff算法判断dom节点是否可以复用，如果可以复用的就进行使用。判断组件是否可以复用，如果不可以复用的时候就会新创建一个组件实例。所以组件真正诞生的时机就是在patch这边进行创建的。同时也是在mouted前进行创建，这样说得过去。

4. diff算法的时候，流程如下：

   - 先创建本VNode的节点
   - 然后进行深度优先遍历子VNode
   - 然后将本节点产生的DOM进行挂载到父亲节点

   所以我们可以总结一下：首先关键词是深度优先遍历，其次是最后再挂载到父亲节点，这样的话最后只会渲染一次，所以可以避免大量回流。并且这种更新的是以组件为基本单位来进行的，所以能够实现局部更新。

- 问题1：说diff的复用，到底是复用什么？

  复用的是DOM（包括标签、文本等）和组件。但是VNode不会复用，因为每次调用渲染函数的时候，都会产生VNode，所以VNode并不会复用，而是通过判断是否可以复用组件，可以复用组件的时候，将VNode的信息进行复制，然后进行复用DOM或者组件。

  如果发现不能复用，那么就会进行创建DOM标签，如果组件不能复用的时候，就会进行创建组件。

- 问题2：diff算法中，key为index的时候，会产生什么问题？

  如果对于内部无状态的组件，也就是说组件状态完全由外部管理的，那么index作为key的话。确实能够有效复用组件，但是对于组件或者标签内部自己管理状态的话，复用就会出问题。