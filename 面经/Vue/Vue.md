[TOC]

### 1.diff算法

#### 抽象化解释

VNode和真实的DOM节点一一对应，然后diff的算法是在更新VNode的前提下，寻找最小的代价来进行更新。并且这个更新过程是一个递归过程，即如果存在子节点可以复用的话，那么会深度优先遍历子节点，进行利用存在的结点，从而达到整棵树上的资源复用。

#### 整个Diff算法的流程

我们以一个例子来说明一下怎么处理：

```js
// 旧列表
oldCh,oldStart,oldEnd
// 新列表
ch,newStart,oldEnd

A | B | C |
A | E | C | B |
```

diff算法，是一种双指针的算法，从两端向中间遍历。

1. 首先是判断两个首结点或者尾结点是否相同，如果相同，不做任何处理。
2. 其次判断旧的首节点和新的尾结点是否相同，如果相同的话，就要进行元素的迁移，即按照新的结点的位置放好
3. 再者是根据key来建立Map，这样的目的是为了简化后面的寻找时间，如果有Key的话，可以将查询时间看作是1，如果没有map的话，是要在数组里面查找，时间复杂度会是n。
4. 最后如果newCh遍历完了，将old数组其他没有遍历到的元素清除掉
5. 如果oldCh遍历完，将newCh数字其他没有遍历到的元素创建。

在上面过程中，如果在更新的时候，是存在子结点的时候，会进行递归遍历子代的Vnode，然后进行diff算法的更新。这就是整个过程。

#### 问题集

##### 1.key为index和key为id的区别

这是在diff算法里面的不同。首先先确定有没有key的区别，也就是说key的作用

- key的作用：在updateChildren的函数中，如果VNode有key的话，那么可以根据key来构建映射，然后在查询那些不是首尾相同的节点的时候去遍历这个map，会比去遍历数组要快。不过如果有map的话，那么在查找不到数据的时候是不会去遍历数组的，所以就相当于该元素不存在。

再来看看index的key和id的key的区别吧：

- index的key在每次渲染前后（只要数据数量一致），那么新VNode的key和旧VNode的key是相同的，默认是会通过map找到对应的下标，然后进行判断标签名、标签data是否相同。
  - 如果是相同的普通标签，那么会进行标签的复用
  - 如果是相同的组件标签，但是实际上是不同的组件实例的话，data会不同，所以以index为key的话，那么如果在中间插入一个组件实例的话，那么后面的都需要重新渲染。
  - 如果是有状态的普通标签的话，如果是input标签，填写内容后。使用数组的unshift方法，那么上面的内容会显示错乱，也就是说数据会向前偏移1位，这也是因为index的原因，会直接去index找数据，然后会判断是sameNode，然后往最后的进行添加数据。

##### 2.sameNode比较的是什么？

- 首先判断key是否相同（如果没有key，那么也是相同的，因为undefined和undefined也相同）
- 判断标签名是否相同
- 判断data是否相同
- 如果是input标签，那么判断input标签的属性是否相同。

##### 3.一个组件的key发生改变后，会发生什么事情？

分析一下流程

1. 首先key发生改变后，会通过map来进行判断两个组件是否是相同，但是由于key是不同的，则会认为是两个不同的组件实例。
2. 使用diff算法判断发现没有能够复用的组件，那么进行会进行组件的销毁与创建。
3. 接下来是组件的销毁与创建过程。