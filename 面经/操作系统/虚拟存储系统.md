# 虚拟存储系统 

### 连续型分区分配

##### 固定式分区分配

- 内存大小固定
- 优点：容易实现
- 缺点：内部碎片比较大

##### 可变式分区分配

- 按需分配内存
- 优点：按需分配，不存在内部碎片
- 缺点：执行过程中，产生外部碎片比较多

##### 分区分配算法

1. 首次适应算法：每次从头开始找到合适的内存进行分配。但是会导致头部内存被使用频率比较高
2. 循环首次适应算法：从上次结束的位置开始找起。
3. 最佳适应算法：每次拿到合适的容量进行分配
4. 最坏适应算法：每次拿到最大容量进行分配

### 离散型分区分配

##### 页式内存分配

- 实现：地址转换机构，页表
- 优点：没有外部碎片，程序不需要连续存放
- 缺点：页内碎片；要求程序全部放进内存，没有足够的内存就无法执行程序

##### 段式内存分配

- 将程序按照逻辑分成大小不等的段，然后每一段就定义相对完整的逻辑信息。
- 实现：地址转换机构，段表（段号，基地址，段大小）
- 优点：程序无需连续存放，并且每一段都具有一定的逻辑关系
- 缺点：进行内存换入换出需要较长时间

##### 段页式内存分配

- 在主存中使用段式内存分配，然后再段中使用页式内存分配
- 优势：在段式中减少内存碎片，并且保持程序的逻辑关系
- 缺点：成本高，实现复杂，由于段大小是基于程序大小来分配，因此，当大面积的内存换入换出的时候，系统会发生“抖动”。

##### 分段和分页的区别

1. 一个程序以一定逻辑来进行分段处理，而分页是没有逻辑区分的
2. 段的大小不定，页的大小是一定的
3. 段向用户提供二维空间，页向用户提供一维空间。
4. 段是信息的逻辑单位，所以是对用户可见的，所以用户可以以一定逻辑来进行分年度按处理，而页是信息的物理单位，所以对于用户是透明的。

### 内存置换算法

##### 最佳适应算法（理想）

##### LRU最久未使用算法

使用双向链表（需要有头尾节点）+hashMap来实现

LinkedHashMap

##### LDU算法

##### 先进先出算法（队列）

**clock时钟算法**

### Socket

##### 原理

为了处理不同计算机、不同进程上的通信问题，但是不同版本、不同协议之间的通信则是成为了问题，由此有了Socket，Socket是以入参的形式来进行沟通的，是TCP/IP中间协议的抽象。

##### 实现

Socket在设计上被抽象成文件，当应用程序创建Socket进程的时候，操作系统会进行创建Socket的，然后Socket将文件描述符传入到创建者进程中，然后进程在调用IO的时候能够通过文件描述符找到Socket

### 进程和线程的区别

1. 进程是一段程序和数据集的一次执行，是资源分配的基本单位
2. 线程是CPU调度的基本单位
3. 线程由进程进行创建。

### 作业、进程和程序的关系：

1. 作业是由程序、数据和操作流程组成
2. 进程是由程序、数据组成

### 进程的状态

1. 就绪状态
2. 执行状态
3. 阻塞状态

### 作业调度的策略

1. 先来先服务
2. 短作业优先
3. 高响应比优先

### 进程调度

1. 先来先服务
2. 优先级
3. 时间片轮转
4. 多级反馈队列

### 死锁的四个条件

1. 互斥条件：资源只能由一个进程使用。
2. 请求与保持条件：进程因请求某一项资源而进入休眠，然后已有资源被保持
3. 不可剥夺条件：进程占用资源的时候，操作系统不可剥夺
4. 环路等待：资源的引用形成一条环

### 解除死锁的方式

1. 预防死锁
2. 避免死锁
3. 检测死锁
4. 去除死锁