1. 项目介绍

2. css

   - 浮动布局：1.父容器坍塌的原因；2.消除浮动
   - 选择器级别：
   - bfc
   - 盒子模型
     - IE6和其他的区别
     - 其他浏览器怎么实现IE6的盒子模型
   - 伪元素

3. 闭包的原理

   - 闭包的应用

   - 闭包的实现跟作用域链的关系

     闭包由于返回的是一个在内部定义的函数，由于词法作用域的关系，它能够访问到该函数作用域链上的变量，所以它延长的作用域链。

4. 类和ES5构造函数的区别：原型上的属性不可被枚举、只能用new来初始化、不存在声明的提升、继承的时候是先调用super使用父类构造器，然后才可以使用this，而ES5是先创建this，再用父类来给this添加属性。

5. call、apply和bind的区别。如果让你设计一个bind，你会怎么设计

   - 在Function的原型上设置一个myBind方法
   - 然后执行的时候，先用变量记住方法名和想要改变的上下文对象
   - 然后返回一个函数，并且这个函数在执行的时候，先把方法放在想要改变的上下文对象中，然后进行执行，最后删除上下文对象中相应的属性

6. new 实现的过程

   - 创建一个空的对象
   - 将这个对象的原型和构造函数指向构造函数的原型和构造函数
   - 以这个对象为执行活动变量，执行构造函数
   - 如果返回的是一个基本数据类型，那么返回这个空的对象，如果不是的话，那么返回相应的对象

7. 前端模块化规范，node、amd、cmd、es6

   - node使用CommonJS，是一个同步加载过程，它的导出是一个值的引用，即修改相应的基本数据变量的话，不会改变到导出内容。
   - ES6是一种动态链接的方式，即修改目标的值，会影响到其他引用的值，并且它在引入的时候，不会去检测是否存在，而是在使用的时候再去检测。
   - Amd、CMd是浏览器上模块化的标准，采用异步加载的方式，即使用JSONP方式来加载。

8. typescript：

   - type和interface的区别
     - Type可以别名基本数据类型，可以声明接口让类来实现、可以通过逻辑与继承。但是声明两个type的时候，是不会合并的。
     - interface可以声明变量类型、接口、可以通过extends继承、声明两个接口的时候会默认合并
   - 类型的好处有哪些
     - 使得软件更可维护
     - 后来者维护的时候更加方便
     - 有助于大型项目的构建和维护

9. 浏览器缓存机制

   - 什么时候使用强制缓存
   - 什么时候使用协商缓存

10. HTTP的ajax请求的流程（也就是网页输入网址的过程）

11. TCP被篡改报文是在什么时候被篡改

12. HTTPS的安全性，即ssl

