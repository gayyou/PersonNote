[TOC]

## MySQL基础

### 检索

- 在检索结果中，如果按照多个条件进行排序的话，那么会按设定顺序排序：即如果前者有相同的项的话，后者会在这些相同的项中进行排序。
- 聚集函数：AVG、MAX、MIN、SUM、COUNT
- 分组查询：
  - group by：列名
  - having是对组别进行过滤：所以having放在group by后边
  - where是对行进行过滤，所以where放在group by前边。
- 相关子查询：涉及到外部查询的查询,内查询查询一次，外查询就查询一次。
- 不相关子查询：内查询只需要查询一遍即可。两者的区别就是相关子查询需要用到外查询的数据，而非相关子查询则不需要。
- 视图：

### 视图

视图是一种虚表，而不是实际存在的表。它是建立在视图之上的规则，每次使用视图的时候，都会用到视图规定的查询语句是查询真正的表。所以它并不会存储数据，而是简化用户的操作。

- Create View...
- Drop VIew....

### 触发器

对于表的操作，INSERT、UPDATE、DELETE都可以使用触发器，触发器是建立在表之上的操作，对于表可以规定，触发器的命名最好是在数据库中是唯一的。

- 只有基本表才能支持触发器，其他比如视图、临时表都不支持触发器。
- 有before和after两种

## 数据库理论基础

### 事务

- 对于数据库表的一组操作，要么全做，要么全不做。
- 命令语句：
  - `start transaction`：开始进入一个事务，在本事务内部对基本表进行修改操作，都可以使用`rollback`进行数据回滚，（仅仅可以对`Insert、delete、update`三种操作，不可对drop、create进行回滚）
  - `rollback`：事务回滚。
  - `commit`：事务提交。
  - `SAVEPOINT`：事务保留点，有些事务在写一半的时候，无论后面是否成功，都要保持前面的操作，那么可以设定一个保留点来将事务进行划分。
    - 在执行一个rollback或者commit的时候自动释放保留点
    - 可以使用release + 保留点名称来进行释放保留点。

### 角色/权限控制

- 数据库具有权限角色之分

### 数据库模型

- 概念模型：从用户的观点看到的数据
- 逻辑模型：数据库数据的组织形式。
- 物理模型：数据库的物理存储形式。

### 数据库安全设计

数据库的安全手段：

##### 1.数据库安全性控制

- 自主存取控制

- 强制存取控制：将数据库分为主体和客体，主体是应用、或者数据库角色。客体是数据库表。

  - 当主体的许可证级别大于客体的数据库密级的时候，可以读取客体的内容；
  - 当主体的许可证级别小于客体的数据库密级的时候，可以写入数据；

  前者很容易理解，但是后者的原因是：如果都是主体的许可证级别大于客体的密级的时候可以读写，那么主体可以将高加密级别的数据写入到低加密级别的数据中，从而没有加密级别的意义。

##### 2.视图控制

将数据库无关密级的数据通过视图展示出来，然后有关加密的数据不进行展示，从而实现数据安全。

##### 3.审计

通过用户的操作日志来进行记录用户的行为。当数据库出问题的时候，进行相对应的处理。

##### 4.数据加密

- 存储加密：采用加密算法对数据进行加密，这样能够防止数据被盗取后不被利用。
- 传输加密：由于mysql是CS的类型的数据库，中间需要通过网络来传输数据，我们可以采用https的形式在传输过程中进行加密操作。

### 数据库完整性

数据库的完整性是指数据库的相容性和正确性。

##### 1.实体完整性

对于数据表的每一行，都有唯一标识这一行的码，叫做主码。主码的检测规则如下：

- 如果该行的主码在其他行中出现，那么拒绝插入或者修改。
- 如果改行的主码不存在，那么拒绝插入或者修改。

##### 2.参照完整性

对于数据表的每一行，如果某个属性关联到外部表中的某个属性，那么该属性不能为空，并且该属性的值一定是所关联表的某个属性的值。

##### 3.用户定义完整性

用户可以自定义某个属性的值的范围。还可以定义CONSTRAINT别名，然后易于修改。

### 关系数据理论

#### 候选码

对于U，存在K，使得K->U，U完全函数依赖于K，把K成为U的候选码

- 如果候选码有多个，那么选择其中一个作为主码
- 在候选码中的属性叫做主属性，否则叫做非主属性

#### 范式

##### 1.1NF

所有属性都是原子属性，不可再分，也也不存在相同的属性列名。满足这样的才叫第一范式.

`字段是最小的单元，不可再分`

##### 2.2NF

在不存在多值属性的基础上。要求定义主属性。实体的属性们要完全依赖于主属性。不存在非主属性对主属性的部分依赖。

`在第一范式的基础上，然后每个非主键都完全函数依赖于主键`

##### 3.3NF

在不存在多值属性、不存在实体的属性部分依赖于主属性的基础上。要求任何非主属性不依赖于其他非主属性。这称之为消除传递依赖。

`在满足第二范式的基础上，非主键外的所有字段都必须互不相依赖`

##### 4.BCNF

不存在多值属性，所有非主属性都完全函数依赖于主属性，不存在非主属性依赖于其他非主属性，并且主属性要完全函数依赖于不包含它的码，即主属性内部不能有部分或者传递函数依赖，这样消除对主属性自己的依赖，使主属性保持最简。

##### 5.4NF

在第三范式的基础上，消除多值依赖，只允许函数依赖

##### 6.5NF

在4NF基础上，消除连接依赖，并且保持数据完整性。

### 事务

#### 1.什么是事务？

所谓事务，是指序列化的一组数据库操作，这些操作要么全做，要么全部做，是一个不可分割的工作单位。

#### 2.事务的ACID特性

##### 原子性（Atomicity）

事务是数据库逻辑工作单位，要么全做，要么全不做。

##### 一致性（Consistency）

事务的执行结果必须是将数据库从一个一致性状态转为另外一个一致性状态，如果执行错误，要返回给原始一致性状态

##### 隔离性（Isolation）

一个事务的执行不能够影响其他事务的执行，即事务的内部操作对其他并发事务是隔离的，并发执行的结果互不干扰。

##### 持续性（Durability）

持续性也称为永久性，即事务的操作应该是永久存在的。



事务ACID特性遭受破坏的情况有两种

- 多个事务并行运行时，不同事务操作交叉执行
- 事务在运行过程中被强行停止。

#### 3.什么是事务隔离，事务隔离的级别？

事务隔离定义了数据库中的一个操作的结果在何时以何种方式对其他并发操作可见。

数据库的隔离级别如下，一下是从低到高的级别。

首先看一下概念：

- 脏读：一个事务读取了另外一个事务中未提交的事务，读取完毕后另外一个事务可能采用回滚。
- 不可重复读：针对于读取的同一条数据，在一次事务中两次读取的内容不一致。也就是读取过程中，其他事务对这条数据进行修改（**针对于行**）
- 幻读：在同一个事务中，进行获取某个条件的数据的长度不一致，原因是其他事务在进行插入数据。（**针对于表**）

**下面有可能是错的**

##### 1.读未提交

最低级别的数据库隔离级别，允许“脏读”存在，事务能够看到其他事务“尚未提交”的修改。但是不允许其他事务在本事务写数据的时候对数据进行修改（允许读），所以使用到了“排他写锁”

##### 2.读提交

不允许脏读，但允许不可重复读，分为两个方面：读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。“瞬间共享读锁”和“排他写锁”

- 不允许脏读：未提交的写事务不允许任何事务对数据进行操作，从而避免了数据脏读。
- 允许不可重复读：在读数据事务的时候允许其他事务对数据进行写入，如果该读取事务操作有两次读取数据，那么会产生读取的结果不一致。

##### 3.可重复读

禁止不可重复读和脏读，但是有时候可能产生幻读。可重复读可以通过“共享读锁”、“排它写锁”来实现，读取事务会禁止其他写事务（但允许读事务），写事务的时候不允许其他操作。

- 不允许脏读：写事务禁止其他事务对数据进行操作
- 禁止不可重复读：读数据事务的时候不允许写数据，所以在读数据事务中，数据不会被任何事务修改。
- 可能会幻读：由于读数据的时候是锁某一行数据，而不是锁整个表，所以在获取数据事务的两条操作中可能会多出几条数据。

##### 4.序列化

提供最严格的事务隔离，要求事务必须序列化，然后一个接着一个进行执行，不能并发执行，仅仅通过“行级锁”是无法实现事务序列化，必须要有一个范围锁来进行限制。

### 并发控制

事务是并发控制的基本单位。而保证是事务的ACID特性是并发控制所需要进行的操作。

锁机制：

- 共享锁：也称为读锁，事务在加锁的时候，允许其他事务来进行读，但不允许修改
- 排它锁：在进行修改的时候，不允许其他事务的任何操作。

##### 1.封锁协议

- 一级封锁协议：事务T在修改数据R的时候必须加入X锁，直到事务结束后才释放。（结束有可能是commit或者rollback）
  - 可以防止修改丢失
  - 读数据没有锁机制，可能导致读脏数据
- 二级封锁协议：在一级封锁协议基础上增加事务T在读取R数据前必须对其加S锁，**读完后**可释放S锁
  - 可以防止读脏数据：：在加入X锁的时候，如果要进行读取数据的时候，必须加读锁，但是X锁是排他锁，所以加不了锁，即无法读。也就是说在事务结束前，其他事务不可读数据。
  - 无法防止不可重复读
- 三级封锁协议：在一级封锁协议基础上增加事务T在读取数据R之前必须先对其加S，直到事务结束后才释放。
  - 由于读取数据的时候，必须在事务结束前才能释放S锁，所以在此阶段中，数据并不能被修改，所以是不存在不可重复读，但是幻读的话是存在的。

##### 2.活锁和死锁

- 活锁：多个事务请求一个数据，然后具有先后到达顺序，但是锁是按照概率抢占式的。导致某个事务一直没有机会拿到锁（理论上能够拿到锁，但是由于概率问题），称为活锁。
  - 抢占时候采用算法，比如先来先服务算法。
- 死锁：A事务占有a数据，B事务占有b数据，并且A事务请求b数据，B事务请求a数据。这样造成环状请求数据锁。永远不能解除，叫做死锁。
  - 死锁的产生条件：
    - 
  - 死锁的预防：
    - 一次封锁法
    - 顺序封锁法
  - 死锁的诊断和解除
    - 超时法：设定超时时间，如果超过这个时间则判断产生了死锁。
    - 等待图法：判断图是否成环，如果成环的话，则发生死锁。图的点代表事务，图的指向代表引用方向。
    - 解除：选择处理死锁代价的最小业务加以撤销，以便造成最小的代价。

##### 3.并发调度的可串行性

- 一个并发调度是正确的条件是当且仅当事务按某一串行化执行的结果相同，成为并发事务的可串行化调度。
- 实现串行化调度的方法
  - 两段锁协议（2PL）：
    - 对任何数据进行读写操作的时候，要申请对该数据的锁。
    - 在释放一个锁之后，事务不再申请和获取任何锁。
  - ps：一次封锁协议和两端锁协议中，一次封锁要求拿到所有锁之后才执行，而段封锁协议则不需要等到拿到全部锁。

##### 4.封锁的粒度

封锁度与并发度和并发控制的开销密切相关。

首先定义一个**多粒度树**，多粒度树的根节点是真个数据库，表示最大的数据粒度，叶节点表示最小的数据粒度。

- 显示封锁：事务的要求直接加到数据对象上的锁；
- 隐式封锁：数据对象没有独立加锁，而是因为父亲结点被显示加锁才会被加锁。

显示封锁和隐式封锁都是一样加锁，对于一个数据进行加锁的时候，需要查看是否被显示封锁，如果没有的话，需要向上级结点查看是否被显示封锁。

- IS：表示子代全部加共享锁
- IX：表示自带全部全部加排他说
- SIX：表示加S锁，然后个别的子代元素为X锁

##### 5.MVCC（多版本并发控制）

多版本控制的思路是针对于每个事务创建一个数据版本，然后相当于并发事务读取相同数据的副本，从而防止并发事务的读取问题。

而优化的MVCC是针对于读是共享读，而写的话是会创建新的版本进行写操作，然后写完毕后去查看读锁是否还在，如果不在的话会进行更新版本。这样就能实现真正的事务并发。

