[TOC]

#  V8的垃圾回收机制

## V8的内存限制

Node通过JavaScript进行运行的时候每个进程会有一定的内存限制，大概如下：

- 在64位的系统中，限制最大的堆内存为1.4GB
- 在32位的系统只，限制最大的堆内存位0.7GB

无论物理内存有多大，一般情况下Node的堆只能用这么大的进程。所以通过Node进行开发的时候，要像戴着镣铐跳舞，要特别注意内存的运用，不要超过V8的内存限制的红线，一旦不小心超过这个限制的时候，进程会结束。 至于为什么不像其他服务端语言没有限制和为什么是限制1.4GB而不是其它的数值，接下来会说的。

------

## V8的对象分配

V8中所有的对象都是存放在堆中，Node提供了V8内存的使用查看方式，只需要在命令行界面输入以下的代码即可看到当前的内存占用的情况。

```javascript
node
> process.memoryUsage();
{
    rss: 14958592
    heapTotal: 7195904
    heapUsed: 2821496
}
```

​	其中rss是进程的常驻内存区，这个先不解释，heapTotal和heapUsed是V8堆内存使用情况，前者是已经申请的堆内存，后者是当前的内存使用量。堆的使用分为已使用的对象区和未使用的对象区，如下图：

![](C:\Users\Administrator\Desktop\堆内存情况.png)

​	当我们创建新的对象，系统会在堆中找一片空闲的区域进行创建，如果创建成功，则可以引用这个对象，如果创建失败的时候，会先进行垃圾回收，然后再进行申请。如果回收后并没有足够的空间容纳这个对象的时候，说明堆已经超出了V8的限制了，则会退出程序。

 	至于为什么是1.4GB而不是其它数值，则是和V8的垃圾回收机制相关：由于js是单线程的语言，它在进行某个操作，即垃圾回收操作的时候，也是要用主线程进行回收，此时会停止其他业务逻辑的进行。V8做一次小的垃圾回收要花50ms，如果做一次非增量式的垃圾回收可能会达到1s以上（1.5GB为例），非常不友好，如果内存过大，则相应的垃圾回收时间也会过长。

​	当然，V8也不是不可以调整堆的限制内存，可以调用以下两种方法进行扩大阙值：

```
node --max-old-space-size=1700 test.js  // 单位为MB
node --max-new-space-size=1024 test.js  // 单位为KB
```

------

## V8的垃圾回收机制

#### V8的垃圾回收算法

​	V8的垃圾回收算法主要是基于分代式垃圾回收机制。

​	在V8中， 主要将内存分为新生代和老生代两部分：新生代中存放着较短生命周期的对象，老生代中存放着生命周期比较长的对象或占用内存比较大的对象，新生代的存放区域大小远小于老生代的大小。新生代的存放大小为64MB（64位系统中），老生代位1400MB(64位系统)。

**Scavenge算法**

​	在分带的基础上，新生代的垃圾回收算法主要是Scavenge算法，该算法的实现思路：将内存分为两个区域，一个正在使用的区域（From），一个是闲置区域（To）。对一些对象的初始化会放到From区域中，闲置区域在触发垃圾回收机制的时候并不会用到。触发垃圾回收机制的时候，遍历使用的区域后，将存活的对象复制到闲置区域中，然后对正在使用的区域进行垃圾回收。然后两个区域的名称对调。每次都是从From中将存活的对象进行复制到To中。

​	这种算法时间复杂度最低，但是需要的空间很高，因为会将内存分为两块，并且只能用到其中的一块。是典型的以空间换取时间的算法。主要是运用在新生代内存区域中，因为新生代内存区域较小，比较合适。

​	经历过一次垃圾回收后还存活，第二次垃圾回收时候还继续存活的对象，系统会自动认为这个对象是比较老的，属于老生代的对象，此时会将对象复制到老生代区域，而不是复制到限制区域。

​	从From区域复制到To区域的时候，会判断闲置区域的内存占用量是否达到25%。如果达到25%，会将该对象复制到老生代中，这是为了避免避免频繁触发垃圾回收机制。

**Mark-Sweep&Mark-Compact**

上面两种垃圾处理方式是老生代中进行垃圾处理的算法。

Mark-Sweep是标记清除的意思，它分为两个阶段：标记阶段和清除阶段。

​	标记阶段：标记阶段遍历堆中所有的对象，标记存活对象。

​	清除阶段：清除那些没有被标记的对象。

但是这个方法的缺点是，进行清除完成后，会出现一些不连续的内存空间。这是由于这种方法仅仅是清除了内存，并没有做其他处理。

Mark-Compact在Mark-Sweep的基础上进行了优化，主要有：标记完后将存活的对象后，在整理的过程中，将存活的对象整理到一边，整理完成后会出现一个完整的内存区域。

三种垃圾回收机制中，Scavenge算法回收机制的效率最高，但是浪费空间，Mark-sweep的效率中等，但是会出现内存分散的现象，Mark-Compact效率最低，但是可以处理处一个比较完整的内存空间。

V8主要在老生代中主要的垃圾处理方法是Mark-Sweep，在空间不足以对新晋过来的新生代对象进行存放的时候才会进行Mark-Compact算法进行处理。

**Incremental Marking**

​	为了避免出现JavaScript应用和垃圾回收器看到的情况不一样，垃圾回收的三种基本算法都需要将应用逻辑停下来，待执行完垃圾回收级之后再恢复应用程序，这种行为成为“全停顿”，在V8的分代垃圾回收中，一次小垃圾回收只收集新生代，由于新生代比较小，存活的对象也比较短，所以全停顿对应用程序影响也不大，但是老生代一般比较大，对象也比较多，全停顿会造成比较大的影响。对此，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，即将任务分为许多小的步进，每完成一个小的步进就对应用程序进行停顿，然后进行垃圾回收逻辑处理直到标记阶段完成。在经过增量标记的改进后，垃圾回收的最大停顿时间会减少到原来的1/6左右。

​	V8还引进额延迟清理和增量式清理。同时还计划引进并行标记和并行处理，进一步利用多核性能降低每次停顿的时间。

------

## 内存指标

#### 查看内存使用情况

​	之前可以使用process.memoryUsage这个方法来进行对内存使用情况进行查看。里面的单位都是字节，可以自己在外部进行封装，以便更好地进行查看。代码如下：

```javascript
const showMem = function () {
    const mem = process.memoryUsage();
    let format = function (bytes) {
        return (bytes / 1024 / 1024).toFixed(2) + 'MB';
    }
    console.log('进程：当前堆占用 ' + format(mem.heapTotal) + ',堆当前用量 ' + format(mem.heapUsed) + '，常驻内存部分用量' + format(mem.rss));
}
```

此外，node还可以查看系统的内存占用情况，代码如下

```
os.totalmem()  // 查看内存总量
os.freemem()   // 查看空闲内存总量
```

#### 堆外内存

​	堆内内存主要是对于JavaScript进程的内存进行限制，但是可以利用一些Node的内建方法实现利用堆外内存，这样可以避免超出堆内内存的使用范围，如buffer方法。

