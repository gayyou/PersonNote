[TOC]

# 异步I/O

### 异步IO是什么？

说起异步，前端开发者最先想到的就是ajax，ajax从发出请求到等待服务器回复的这段时间中，主线程能够执行下来的程序代码，直到服务器返回结果后，再执行回调的内容。异步能够避免当调用一个需要长时间执行的程序时候造成卡顿。异步非堵塞在生活中的例子：当你同时和很多人在wechat上面进行聊天的时候，异步就是发送完信息然后去和下一个人进行聊天；同步的话是跟一个人进行聊天，把天聊完了才去跟另外一个人进行聊天。显然异步和同步的效率差距明显。

### 为什么要用到异步IO？

在web2.0时代中，一个网页/程序的用户量激增，伴随着用户量的增长，请求的数量会特别多，所以高效处理并发成为一个很重要的技术，而node的开发初衷则是想要有一个高性能的后台。

### 资源分配

单线程执行方式比较符合开发者的思维，但是普通的单线程是同步操作，即对一个代码块进行执行时候，将一个操作执行完毕才进行下一步执行。如果一个操作执行的时间特别长，则会影响后面的请求的执行，不适合大型网页的开发。对于这种情况，则出现了多线程进行执行，但是多线程只是相当于多个单线程进行处理，并不能够提高单个请求的执行速率（可提高多个相同的请求的执行速率）。

### 操作系统内部的阻塞io/非阻塞io

操作系统对设备进行抽象处理，将所有的输入和输出都抽象成为文件。





阻塞io：

	阻塞IO：阻塞调用后，当数据读取完毕的时候返回数据，在读取数据这段时间内，cpu在等待IO操作，并无其他操作。
	
	非阻塞IO：非阻塞调用后，立即返回。CPU可以在接下来的时间片执行下一步操作，判断IO是否操作成功需要用到轮询，具体有以下几种实现方式：

 	1. read：调用后，会不断去轮询是否io操作成功，这段时间内cpu会一直耗用在等待上。所以这是一个很低效率的方式，跟阻塞io差不多。
 	2. select：这是一个记录io操作状态的数组，只有1024个元素的数组。当进行一次调用io操作的时候，会将这个io操作的文件描述符存放在select数组中，此时cpu可以继续执行下一个操作。而select由一个专门的线程进行监听，一旦监听到某个文件描述符完成时候，进行回调到主线程。
 	3.  poll：这是select的链表形式，解决了长度问题。
 	4. epoll：这个是linux中一种高效的IO事件通知机制。select和poll都会不断对顺序表进行轮询，但是这这种模式中，一旦进入轮询的时候没有检查到io事件，会进入休眠，直到有io事件将其唤醒。它是真正用到了事件通知机制。
 	5. kqueue：这个类似于epoll。只是这个是在FreeBSD系统下存在的。

以上这五种非阻塞的io，只是在操作系统内核而言的，而在应用程序中看来，也是会堵塞的，应用程序只有在获得数据读取后，才会进行下一步操作。所以对于应用程序而言，也是同步io。

### 理想中的非阻塞异步IO

	理想中的非阻塞异步IO是由应用程序发起的io操作，无需通过遍历或者事件唤醒方式进行轮询，只需要等待io操作回调函数的执行。在IO操作的过程中，主线程可以不管这个IO操作而进行其他操作，当IO操作完毕后这个IO操作的回调函数会放在主线程的执行队列中，待主线程进行下一步操作。linux中存在一种这样的执行方式，叫做AIO，但是它有一个缺陷就是无法使用系统缓存。

### 现实中的异步IO

	现实中有线程池模拟异步IO。是用多线程来模拟这个异步IO，即有一个主线程和多个IO线程，当主线程进行IO操作的时候，会调用一个IO线程，从而主线程可以进行下一步操作，继续调用其他IO操作。在一个IO操作完毕后，会返回一些数据，并执行，这是AIO用多线程来模拟异步单线程。
	
	window的IOCP，在某种程度上实现了单线程异步操作，即调用IO，执行下一步，IO调用完毕，进行回调。用户无需考虑到对IO进行轮询，一旦IO执行完毕后会进行回调操作。因为window的IOCP跟Node的异步执行非常相似，所以Node在windows中用IOCP进行异步操作，而在*nix中，使用了自定义的线程池。
	
	有人会说，那开发一个程序，还要考虑到不同的系统，是不是需要开发不同的版本？这是不用担心的，在Node.js和底层中间还有一层封装，是专门对系统进行判断从而使用不同的方式。
	
	IO是不仅仅只是磁盘数据的读写，只要关于输入输出的都适用。



​	

​	