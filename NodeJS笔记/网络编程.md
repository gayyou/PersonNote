# 网络编程

## 构建TCP服务

​	TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。具体的话可以看一下计算机网络。

​	nodejs中服务器不像其他语言需要借助比如apache或者Nginx等服务器平台。nodejs中的核心模块中已经封装有服务器，使用时候直接导入net模块就可以使用TCP协议来创建TCP的服务端或者客户端。以下是创建TCP服务端。

#### 创建TCP服务器端

在基本了解NodeJS中的TCP后，我们可以通过以下代码进行创建TCP服务器：

```JavaScript
const net = require('net');

let server = net.createServer(socket => {
    socket.on('data', data => {
        if (data) {
            console.log(data.toString());
        }
        socket.write('你好');
    });

    socket.on('end', () => {
        console.log('断开了');
    });

    socket.write('欢迎访问TCP服务器');
});

server.listen(8081, () => {
    console.log('服务器创建成功');
});
```

这个TCP的服务端端口为8081。下面我们通过net来创建一个TCP的客户端进行访问：

```JavaScript
const net = require('net');

let client = net.connect({ port: 8081 }, () => {
    console.log('服务已经创建完毕');
    client.write('world!\r\n');
});

client.on('data', data => {
    console.log(data.toString());
    client.end();
});

client.on('end', () => {
    console.log('服务已经结束');
});
```

这样就实现了TCP的服务器的访问。结果如下：

![1547609299012](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1547609299012.png)

![1547609321984](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1547609321984.png)

除了用端口外，我们还可以用Domain Socket来进行监听，代码如下：

```JavaScript
server.listen('/tmp/echo.sock');
```

客户端进行连接的时候，代码如下：

```JavaScript
let client = net.connect({ path: '/tmp/echo.sock' })
```



#### TCP服务的事件

1. 服务器事件：
   - listening：在调用server.listen绑定端口或者Domain Socket后触发，简洁写法为server.listen(port, listeningListener)，通过listen方法的第二个参数传入。
   - connection：每个客户端套接字连接到服务端时触发。
   - close：服务器关闭时候触发，当调用server.close()的时候，服务器会停止接受新的套接字，但保持当前存在的连接，当所有连接都断开的时候，会触发该事件。
   - error：服务器发生异常时候触发，如果不监听error的时候，服务器会抛出异常。

2. 连接事件：
   - data：当一端调用write发送数据的时候，另一端会触发data事件，事件传递的数据即是write发送的数据。
   - end：当连接中的任意一段发送FIN数据，会触发该事件。
   - connect：客户端连接服务端。
   - drain：当某一端调用write方法的发送数据的时候会调用该方法。
   - error：发生异常的时候，触发该事件。
   - close：当所有套接字完全关闭的时候，触发该事件。
   - timeout：设置请求闲置的最大时长。

值得一提的是：TCP对小数据包具有优化的策咯，面对一些小的数据包，会调用Nagle算法进行合并后进行发送，Node中也有调用这个方法。去除的话可以使用以下代码：

```JavaScript
socket.setNoDelay(true);  // 去除Nagle算法
```

这样做接收端会接受到所有数据后进行合并，再触发data事件。

------



## 构建UDP服务

​	UDP又称用户数据包协议，与TCP一样属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的，TCP连接一旦建立后，所有的会话都基于连接完成，客户端如果想要与另外一个TCP服务通信，则需要另外创建一个TCP套接字来完成，但是UDP中则不需要，一个套接字可以和多个UDP服务通信。UDP面向不可靠的网络传输，在网络差的时候存在掉包严重的问题，但是由于它无需连接，资源消耗低，处理快速灵活等特点，所以常常用来做一些偶尔掉一两个包也没什么关系的场景，比如视频、音频等。

#### 创建UDP套接字

​	UDP套接字一旦创建完毕，既可以作为服务端进行接收数据也可以作为客户端进行发送数据，代码如下：

```JavaScript
const dgram = require('dgram');
let socket = dgram.createSocket('udp4');  // 创建套接字
```

#### 创建UDP服务端

想让UDP套接字接收网络消息，只要调用dgram.bind方法即可，代码如下：

```javascript
const dgram = require('dgram');

let server = dgram.createSocket('udp4');  // 创建套接字

server.on('message', (msg, rinfo) => {
   console.log('server got:' + msg + ' form ' + 
               rinfo.address + ':' + rinfo.port); 
});

server.on('listening', () => {
	let address = server.address();
    console.log('server listening ' + address.address + ':' + address.port);
});

server.bind(41234);
```

该套接字将接收端口号为41234的消息。

#### 创建UDP客户端

创建客户端的代码如下：

```JavaScript
const dgram = require('dgram');

let message = new Buffer('深入浅出NodeJS');
let client = dgram.createSocket('udp4');
client.send(message, 0, message.length, 41234, 'localhost', (err, bytes) => {
    client.close();
});
```

发送的时候send的参数分别是：Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调。

#### UDP套接字事件

UDP套接字相对于TCP套接字使用起来简单，仅仅是EventEmitter的实例，而不像TCP是Stream的实例

- message：当UDP套接字监听了网卡段号后，接收到信息时候触发的事件。
- listening：当UDP套接字开始监听的时候触发的事件。
- close： 滴啊用close方法时触发该事件，并不再发送message事件，如需再次触发message事件，重新绑定即可。
- error：当异常发生的时候，如果不监听，则将异常直接抛出，退出进程。

------



## 构建http服务

#### HTTP

HTTP全称为超文本传输协议。构建在TCP之上，在HTTP协议中的两端是服务器和浏览器，即著名的B/S模式。

构建http服务器的代码如下：

```JavaScript
const http = require('http');

http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('hello world\n');
}).listen(8089, 'localhost');
console.log('服务器已经在运行了');
```

HTTP报文：启动http服务端后，我们可以用curl工具，通过-v选项进行显示本次网络通信的所有内容。代码如下：

```javascript
curl -v http://localhost:8089?index=2

Trying ::1...
* TCP_NODELAY set
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8089 (#0)
> GET /index=2 HTTP/1.1     // 请求的报文头和报文体（get请求的数据是放在url中，不存在报文体，但是可以传输数据，这里将其看做报文体）
> Host: localhost:8089
> User-Agent: curl/7.63.0
> Accept: */*
>
< HTTP/1.1 200 OK    // 回复时候的报文头
< Content-Type: text/plain
< Date: Wed, 16 Jan 2019 12:07:45 GMT
< Connection: keep-alive
< Transfer-Encoding: chunked
回复结束					//报文体
```

无论是http请求报文和http回复报文，报文的内容都分为两部分：报文头和报文体。

