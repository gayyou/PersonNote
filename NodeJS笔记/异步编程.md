# 异步编程

#### 函数式编程

​	JavaScript语言函数占比较重要的地位，函数既可以普通调用，又可以当做函数的参数或者函数的返回值。这样的好处在于灵活，当作为参数的时候可以执行回调函数。

------

#### 异步编程的优势与难点

​	优势：异步编程的最大特点莫过于基于事件驱动的非阻塞IO模型。这个模型可以将cpu与IO读取互不依赖等待，从而让资源更好地利用，从而提高程序的效率。

​	难点：异步编程的难点在于以下几点

- **异常处理**：由于异步程序分为请求调用和处理结果两部分，中间存在事件循环，所以两部分并不是关联的。换句话说，请求调用并不能获得处理结果时候的异常。
- **函数嵌套太深**：异步编程中，会在代码中监听事件变化函数，如果存在多个串行异步调用，则会导致代码嵌套过深，不易于代码的阅读。
- **阻塞代码**：JavaScript并不存在线程休眠，如果某个步骤要求线程停止一定的时间，此时有的程序员会写出阻塞代码，导致JavaScript停滞。
- **多线程编程**：JavaScript是单线程语言，无法较好地利用多核CPU，这就导致无法作为高效的服务器。前端浏览器有Web Worker，Node中有child_process和cluster来进行多线程。
- **异步转同步**：如果出现需要同步处理的业务的时候，会比较吃力。

------

#### 异步编程的解决方案

​	大概有三种解决方案：

- 事件发布/订阅模式
- Promise/Deferred模式
- 流程控制库

##### 事件发布/订阅模式

​	调用Node自身的event模块，先对事件进行订阅，待到条件充足的时候对事件进行发布。实例代码如下：

```JavaScript
var EventEmitter = require('events').EventEmitter; 
var event = new EventEmitter(); 
event.on('some_event', function() {  // 订阅事件  
    console.log('some_event 事件触发'); 
}); 
setTimeout(function() {   
    console.log('隔了一秒后');
    event.emit('some_event');   // 事件发布
}, 1000); 
// 隔了一秒后
// some_event
```

这种模式常常用来解耦业务逻辑，事件发布者无须关注订阅监听器如何实现业务逻辑，只需要传递信息信息就行了。这样可以将调用、回调分离开来，只关注事件是否产生就可以了。

​	从另外一个角度上看，事件发布/订阅模式也是一种hook，JavaScript是词法作用域，外部是无法访问对象中的值，而事件订阅/发布模式则可以通过传参来进行获取对象中的值。

​	应用：利用事件队列来解决雪崩问题。在服务器中，有时候会在短时间内产生大量请求，如访问数据库，这时候如果利用这个模式中的once方法，则可以通过事件队列来解决雪崩问题。此时需要用到锁。

这是一句普通的数据库查询语句，如果存在大量需要查询数据操作的时候，可能会崩掉。

```JavaScript
var select = function(callback) {
    db.select('SQL', function(results) {
        callback(results);//比如传入的函数是展示数据，那么该句的作用就是将查询后返回的数据展示出来
    });
};

```

这里通过状态锁来进行处理高并发。如下：

```JavaScript
var status = 'ready';
var select = function (callback) {
    if (status === 'ready') {
        status = 'pending';
        db.select('SQL', function (results) {
            callback(results);//比如传入的函数是展示数据，那么该句的作用就是将查询后返回的数据展示出来
            status = 'ready';
        });
    }
};
```

遇到高并发的时候，会对一个请求一个请求进行数据库查询，从而避免遇到雪崩式的请求。

在这里我们用事件队列来进行请求查询：

```JavaScript
var proxy = new EventProxy();
var status = 'ready';
var select = function (callback) {
    proxy.once('selected', callback);//将该实例的该操作放入队列，并且操作只执行一次
    if (status === 'ready') {
        status = 'pending';
        db.select('SQL', function (results) {
            proxy.emit('selected',results);//将该操作返回的数据作为回调函数的输入参数，执行回调函数
            status = 'ready';
        });
    }
};
```

