# 入口

```
文件路径：
src\core\instance\index.js
```

创建Vue对象时候的入口就是这个文件中的vue，其中代码如下：

```JavaScript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

// vue类
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    // 当不是用构建函数构建的时候，报错
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
  // 格局设置初始化vue*实例*对象
}

// 利用设计模式中的混入模式在Vue对象中混入方法
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

****

先上代码及其注释

```typescript
const dataDef = {}
  dataDef.get = function () { return this._data }
  const propsDef = {}
  propsDef.get = function () { return this._props }
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      )
    }
    propsDef.set = function () {
      warn(`$props is readonly.`, this)
    }
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef)
  Object.defineProperty(Vue.prototype, '$props', propsDef)
```

我们先看最后两句，使用 `Object.defineProperty` 在 `Vue.prototype` 上定义了两个属性，就是大家熟悉的：`$data` 和 `$props`，这两个属性的定义分别写在了 `dataDef` 以及 `propsDef` 这两个对象里，我们来仔细看一下这两个对象的定义，首先是 `get` ：

```javascript
// 首先，dataDef和propsDef实际上是一个代理对象，代理_data和_props这两个对象。
const dataDef = {}
dataDef.get = function () { return this._data }
const propsDef = {}
propsDef.get = function () { return this._props }
```

其次是set方法：

```JavaScript
// 先不用管warn具体干了什么，但是能知道的是警告方面的，这个是告诉开发者，不能够对这个对象进行设置
dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      )
}
propsDef.set = function () {
  warn(`$props is readonly.`, this)
}
```

由上面代码可以看出，设置一层代理层则是想要$data,$props这两个属性只读不写。那么为什么要进行代理呢，答案很简单，解耦，模块化，可能其他模块会用到，并且可以进行写入。

接下来是三个属性：

```JavaScript
  Vue.prototype.$set = set
  Vue.prototype.$delete = del

  Vue.prototype.$watch = function (
    expOrFn: string | Function,
    cb: any,
    options?: Object
  ): Function {
  	// ...
  }
```

上面代码有三个属性$set,$del,$watch

先从set开始看起

```typescript
export function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    // 判断是否存在并且是否是原始数据类型，isPrimitive是判断是否是Number、string、Symbol、boolean，即除了object数据类型外
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 判断目标数组是否可用
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    // 判断这个键值在这个target中并且key不是Object对象的键值
    target[key] = val
    return val
  }
  // 目前暂时不知道这段代码的用处
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  // 如果以上都不存在，说明这个值并不存在于这个对象中，那么就要在对象中进行声明，并且调用nitify，即让观察者对象知道这个对象发生改变了。
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
```

其实看得懂上面的代码，del那个方法也是差不多这个意思。set就是设置对象属性，del就是删除属性，watch是观察这个对象是否发生变化，即创建一个观察者对象。



Date：2019/03/26

Author：Weybn