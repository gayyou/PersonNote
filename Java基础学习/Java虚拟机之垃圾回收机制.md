# Java虚拟机之垃圾回收机制

### 1.引用有多少种，分别有什么特点？

1. 强引用： 在本地变量或者实例对象的属性直接引用的就是强引用，除非把手动吧指针弄成null，不然一般是不会被回收的。
2. 软引用：可用但并不是必须的，在内存充足的时候并不会进行回收，但是在发生Full GC的时候会将这个软引用的内容进行清除
3. 弱引用：弱引用总是会在下次GC的时候进行清除。
4. 虚引用：虚引用字如其名，只是引用并不会对原本对象的是否被GC产生影响。

### 2.判断对象是否能够被清除的方式有哪几种，特点是什么？

1. 计数法：这种方法是在对象上加一个字段，每当这个对象被引用的时候，这个count就++，但是有个问题，就是存在循环引用的问题
2. 图的可达性法：这种方法是把堆中所有的对象看做图的节点，从GC ROOT开始遍历器，把所有能够达到的节点的标志 ，然后那些没有标志的就是不可达，那么要进行清除。

### 3.讲一下GC回收算法有多少种，分别讲出它们的特点？

1. 标记-清除：先进行标记，然后再进行清除节点，但是会出现一种情况，就是内存碎片，虽然内存总和是足够的，但是每一块大小如果不满足要求的话，就会出现oom
2. 标记-整理：先进行标记，然后把存活的对象整理到内存的一边，然后再把另外一边进行清除。
3. 复制：用于新生代，把内存进行划分，分成一个主的和一个存活的对象，直接把主的存活的对象复制到从的，然后把主的全部清除，然后对换大小。

### 4.讲一下垃圾收集器大体上分为哪几种，并且种类内有多少个，它们的特点是什么？

- 垃圾回收器大体上按照使用的内存区块的话，分成新生代和老年代（还有一个两边都通用的）

- 如果按照是否存在和用户线程同时进行的话，可以分成单独占用的和并行的。

1. Serial：特点是暂停其他用户线程和单线程GC，缺点是慢，复制算法

2. Serial Old：老年代的整理方式，是标志-整理

3. ParNew：新生代的内存整理方式，与Serial相比是多线程，也是复制算法

4. MSC：多线程的老年代整理方式，也是标志-整理

5. Parallel：新生代的，多个整理线程并行的，面向吞吐量的，也就是用户可以通过控制吞吐量来控制新生代的大小，从而控制单次GC的时间

6. Parallel Old：老年代的，也是多喜爱能成并行的面向吞吐量的。标记-整理

7. CMS：并发算法，面向老年代的，（标记-清除）有如下的流程：

   1. 初始标记：把直接与GC ROOT相连的对象标记起来，在并发标记的时候不会再标记上new出来的，存放在本地变量的对象
   2. 并发标记：以初始标记的对象为起点，然后遍历整个堆，进行标记
   3. 重新标记：把并发期间连接起来的对象进行标记
   4. 并发清除：清除

   缺点：存在浮点垃圾、存在内存碎片、占用CPU

8. G1算法：G1算法在思想上是分成新生代和老年代，但是在物理上是不会进行区分新生代和老年代的。它将内存分为一块一块的，通过类似于CMS的方式来进行标记，然后使用类似于标记-整理的方式，克服了CMS的内存碎片。

### 5.简单讲述一下内存分配和回收策略。

 新生代：一般比较小的对象，会被放到新生代，并且jvm会在这个对象上标注一个年龄，代表这个对象在内存中的年龄，只要发生一次GC，那么这个年龄就会增长，如果增长到一定岁数，就会进入到老年代。进入到老年代的依据还有，如果某个年龄段的对象占新生代的大小为一半以上，那么这个年龄和比他老的对象都会直接进入到老年代。

老年代：大对象会直接进入到老年代中，老年代产生的GC就是FULL GC，时间是新生代的10倍以上。老年代还可以为新生代的survivor区域提供担保，就是如果survivor区域无法把所有的存活的对象进行移动的话，那么会在老年代提供一个区域存放新生代。

### 6.简述一下如何怎么做能够减少GC次数。